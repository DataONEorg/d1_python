

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Architecture &mdash; ONEDrive 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ONEDrive 1.0.0 documentation" href="index.html" />
    <link rel="next" title="1. Setup" href="setup.html" />
    <link rel="prev" title="2. Launching ONEDrive" href="run.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="setup.html" title="1. Setup"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="run.html" title="2. Launching ONEDrive"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">ONEDrive 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Architecture</a><ul>
<li><a class="reference internal" href="#production">3.1. Production</a></li>
<li><a class="reference internal" href="#testing-and-debugging">3.2. Testing and Debugging</a></li>
<li><a class="reference internal" href="#resolvers">3.3. Resolvers</a><ul>
<li><a class="reference internal" href="#the-hierarchy-of-resolvers">3.3.1. The hierarchy of resolvers</a></li>
<li><a class="reference internal" href="#notes">3.3.2. Notes</a></li>
<li><a class="reference internal" href="#the-root-resolver">3.3.3. The Root resolver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#command-processor">3.4. Command processor</a></li>
<li><a class="reference internal" href="#path-representation">3.5. Path representation</a></li>
<li><a class="reference internal" href="#searching-in-the-onedrive-filesystem">3.6. Searching in the ONEDrive filesystem</a></li>
<li><a class="reference internal" href="#callbacks">3.7. Callbacks</a><ul>
<li><a class="reference internal" href="#getattr">3.7.1. getattr()</a></li>
<li><a class="reference internal" href="#readdir">3.7.2. readdir()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#returning-error-messages">3.8. Returning error messages</a></li>
<li><a class="reference internal" href="#debugging">3.9. Debugging</a></li>
<li><a class="reference internal" href="#index">3.10. Index</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">4. Indices and tables</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="run.html"
                        title="previous chapter">2. Launching ONEDrive</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="setup.html"
                        title="next chapter">1. Setup</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/architecture.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="architecture">
<h1>3. Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="production">
<h2>3.1. Production<a class="headerlink" href="#production" title="Permalink to this headline">¶</a></h2>
<p>The main components of ONEDrive when in regular operation.</p>
<p class="graphviz">
<img src="_images/graphviz-134f55bdae817fc790b56b41f32249ecd1523def.png" alt="digraph G {
  ranksep = .75;
  size = &quot;7,20&quot;;
  dpi = 72;
  node [shape = box];
  &quot;ONEDrive&quot; -&gt; &quot;FUSE Callbacks&quot;
  &quot;ONEDrive&quot; -&gt; &quot;Dependency Checker&quot;
  &quot;FUSE Driver&quot; -&gt; &quot;FUSE Callbacks&quot;
  &quot;FUSE Callbacks&quot; -&gt; Cache
  &quot;FUSE Callbacks&quot; -&gt; Resolvers
  &quot;Utility Classes&quot; -&gt; Resolvers
  &quot;Resolvers&quot; -&gt; &quot;Command Processor&quot;
  &quot;Command Processor&quot; -&gt; &quot;Solr Client&quot;
  &quot;Command Processor&quot; -&gt; &quot;DataONE Client&quot;
}

/*
    subgraph cluster0 {
      node [style=filled, color=white];
      style=filled;
      color=lightgrey;
      label = &quot;Utility Classes&quot;;
      &quot;Directory&quot;
      &quot;FacetPathParser&quot;
      &quot;Filename Extensions&quot;
      &quot;PathException&quot;
      &quot;QueryEngineDescription&quot;
      &quot;Resolver ABC&quot;
      &quot;Settings&quot;
    }
*/" />
</p>
<p>The utility classes include <tt class="docutils literal"><span class="pre">Directory</span></tt>, <tt class="docutils literal"><span class="pre">FacetPathParser</span></tt>,
<tt class="docutils literal"><span class="pre">PathException</span></tt>, <tt class="docutils literal"><span class="pre">Filename</span> <span class="pre">Extensions</span></tt>, <tt class="docutils literal"><span class="pre">QueryEngineDescription</span></tt>,
<tt class="docutils literal"><span class="pre">ResolverABC</span></tt>, <tt class="docutils literal"><span class="pre">Settings</span></tt>.</p>
</div>
<div class="section" id="testing-and-debugging">
<h2>3.2. Testing and Debugging<a class="headerlink" href="#testing-and-debugging" title="Permalink to this headline">¶</a></h2>
<p>The main components of ONEDrive when testing and debugging.</p>
<p class="graphviz">
<img src="_images/graphviz-af9fa0ee89c4270747894460e27a058ff005f09a.png" alt="digraph G {
  ranksep = .75;
  size = &quot;7,20&quot;;
  dpi = 72;
  node [shape = box];
  &quot;Unit Tests&quot; -&gt; Resolvers
  &quot;Unit Tests&quot; -&gt; &quot;Utility Classes&quot;
  &quot;Resolvers&quot; -&gt; &quot;Command Echoer&quot;
}" />
</p>
<p>When testing and debugging, the FUSE specific classes are replaced by the unit
testing framework. Also, <a class="reference internal" href="#command-processor">Command Processor</a> is replaced with <tt class="docutils literal"><span class="pre">Command</span>
<span class="pre">Echoer</span></tt>, a component that simply echoes the commands back instead of returning
actual results. The unit tests for the resolvers compare the echoed commands
with the commands that were expected to be issued for a given path.</p>
<p>One consequence of this is that the FUSE related classes and the <tt class="docutils literal"><span class="pre">Command</span>
<span class="pre">Processor</span></tt> are not tested. There is almost no code in the FUSE related classes
and what is there is linear in nature and is fully tested for each time the
drive is mounted and a path is opened. The <tt class="docutils literal"><span class="pre">Command</span> <span class="pre">Processor</span></tt> contains more
logic but is hard to test reliably since it interacts with databases that change
over time.</p>
<p>This layout facilitates TDD, as the unit tests can be run quickly, with
reproducible results.</p>
</div>
<div class="section" id="resolvers">
<h2>3.3. Resolvers<a class="headerlink" href="#resolvers" title="Permalink to this headline">¶</a></h2>
<p>The resolvers are classes that &#8220;resolve&#8221; filesystem paths to lists of files and
folders for those paths. The resolvers are arranged into a hierarchy. Each
resolver examines the path and may resolve the path itself and/or pass control
to another resolver. If a resolver does both, its list of files and folders
appears above the ones provided by resolvers deeper in the hierarchy.</p>
<p>Resolvers deeper in the hierarchy corresponds to sections that are further to
the right in the path. If a resolver passes control to another resolver, it
first removes the section of the left side of the path that it processed. Thus,
each resolver needs to know only how to parse the section of the path that it is
designed to handle. This also enables the same functionality to be exposed
several places in the filesystem. For instance, the resolver for the object
package level can be reached though each of the root level search types.</p>
<p>If a resolver determines that the path that it has received is invalid, it can
abort processing of the path by raising a PathException. The resolver stores a
brief error message in the exception. The exception is caught by the Root
resolver, which renders it as a file in the ONEDrive filesystem, using the
error message as the filename.</p>
<div class="section" id="the-hierarchy-of-resolvers">
<h3>3.3.1. The hierarchy of resolvers<a class="headerlink" href="#the-hierarchy-of-resolvers" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/graphviz-99936c8349eec440fb1db02ae1e744676e9564c8.png" alt="digraph G {
  ranksep = .75;
  size = &quot;7,20&quot;;
  dpi = 72;
  node [shape = box];
  {
    rank = same;
    Root;
  }
  {
    rank = same;
    &quot;Preconfigured Search&quot;;
  }
  {
    rank = same;
    &quot;Faceted Search Selector&quot;;
    &quot;Flat Space&quot;;
    Status;
  }
  {
    rank = same;
    &quot;Faceted Search&quot;;
  }
  {
    rank = same;
    &quot;DataONE Object&quot;;
  }
  {
    rank = same;
    Package;
  }
  {
    rank = same;
    &quot;Science Object&quot;;
  }

  Root -&gt; &quot;Faceted Search Selector&quot;;
  Root -&gt; &quot;Preconfigured Search&quot;;
  Root -&gt; &quot;Flat Space&quot;;
  Root -&gt; Status

  &quot;Faceted Search Selector&quot; -&gt; &quot;DataONE Object&quot;;
  &quot;Faceted Search Selector&quot; -&gt; &quot;Faceted Search&quot;;
  &quot;Preconfigured Search&quot; -&gt; &quot;Faceted Search Selector&quot;
  &quot;Flat Space&quot; -&gt; &quot;DataONE Object&quot;;
  Status -&gt; &quot;Coordinating Nodes&quot;;
  Status -&gt; &quot;Member Nodes&quot;;

  &quot;Faceted Search&quot; -&gt; &quot;DataONE Object&quot;;

  &quot;DataONE Object&quot; -&gt; Package
  &quot;DataONE Object&quot; -&gt; &quot;Science Object&quot;

  Package -&gt; &quot;Science Object&quot;
  Package -&gt; &quot;System Metadata&quot;

  &quot;Science Object&quot; -&gt; &quot;System Metadata&quot;
  &quot;Science Object&quot; -&gt; &quot;Science Metadata&quot;
  &quot;Science Object&quot; -&gt; &quot;Science Data&quot;
}" />
</p>
</div>
<div class="section" id="notes">
<h3>3.3.2. Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">The resolvers are all derived from <tt class="docutils literal"><span class="pre">ResolverABC</span></tt>, not from each other.</p>
</li>
<li><p class="first">Each resolver has two public methods, <tt class="docutils literal"><span class="pre">get_attributes()</span></tt> and
<tt class="docutils literal"><span class="pre">get_directory()</span></tt>. <tt class="docutils literal"><span class="pre">get_attributes()</span></tt> returns the attributes for a file or
folder. <tt class="docutils literal"><span class="pre">get_directory()</span></tt> returns the directory contents for a folder.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">Root</span></tt> resolver renders the root directory, which contains a set of
directories designating different types of interactions which can be performed
with the DataONE infrastructure. It also parses the root elements of paths and
transfers control to the appropriate path resolver.</p>
</li>
<li><p class="first">All the resolvers handle paths as lists of path segments. The root resolver
performs the conversion of the path string to a list of path segments by
splitting the path on the path separator and unescaping the segments. This
allows the path segments to contain DataONE identifiers that include the path
separator and simplifies path handling in the resolvers.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">Faceted</span> <span class="pre">Search</span> <span class="pre">Selector</span></tt> exists so that faceted search can be turned
off once a specific object has been selected. In other words, the path:</p>
<div class="highlight-python"><pre>/FacetedSearch/@facet1/#value1/@facet2/#value2/mydataonepid/science_object.jpg</pre>
</div>
<p>does not cause a faceted search to be performed even though one is included.
The user has already found and selected an object, so the <tt class="docutils literal"><span class="pre">Faceted</span> <span class="pre">Search</span>
<span class="pre">Selector</span></tt> just strips the faceted search section off the path and passes
control to <tt class="docutils literal"><span class="pre">Package</span></tt>. This eliminates superfluous searches. It also causes
the path to remain valid even if the specified object stops matching the
facets in the future.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Faceted</span> <span class="pre">Search</span></tt> also appears under <tt class="docutils literal"><span class="pre">Preconfigured</span> <span class="pre">Search</span></tt>. This enables
the user to specify preconfigured searches for various classes of objects of
interest while still enabling the user to use faceted search to further narrow
down the results from the preconfigured searches.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Flat</span> <span class="pre">Space</span></tt> enables direct access to objects and enables users to share
short ONEDrive paths to directly access specific objects.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">DataONE</span> <span class="pre">Object</span></tt> determines what type of object has been selected and calls
a resolver that is appropriate for the type. Currently, regular science
objects and packages are supported.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Package</span></tt> renders the contents of a OAI-ORE Resource Map.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">Status</span></tt> hierarchy is not implemented. It&#8217;s just an indication of how
other DataONE related information can be exposed in the filesystem.</p>
</li>
</ul>
</div>
<div class="section" id="the-root-resolver">
<h3>3.3.3. The Root resolver<a class="headerlink" href="#the-root-resolver" title="Permalink to this headline">¶</a></h3>
<p>As an example of the pattern that the resolvers follow, consider the Root
resolver. The Root resolver is responsible for rendering the root directory,
<tt class="docutils literal"><span class="pre">/</span></tt>, and for dispatching paths out to the other resolvers. Only the root
folder is handled by the Root resolver.</p>
<p><tt class="docutils literal"><span class="pre">get_attributes(&quot;/&quot;)</span></tt>: Return the attributes for <tt class="docutils literal"><span class="pre">/</span></tt> (0 size, directory).</p>
<p><tt class="docutils literal"><span class="pre">get_attributes(&quot;/FacetedSearch&quot;)</span></tt>: Not handled by the Root resolver. The Root
resolver strips off <tt class="docutils literal"><span class="pre">/FacetedSearch</span></tt>, and passes the remaining path, <tt class="docutils literal"><span class="pre">/</span></tt> to
the FacetedSearch resolver. So, even though <tt class="docutils literal"><span class="pre">/FacetedSearch</span></tt> is returned by
<tt class="docutils literal"><span class="pre">get_directory(&quot;/&quot;)</span></tt> (see below) of the Root resolver, that same path is not
handled by the Root resolver.</p>
<p><tt class="docutils literal"><span class="pre">get_attributes(&quot;/FacetedSearch/some/other/path&quot;)</span></tt>: Same as
<tt class="docutils literal"><span class="pre">get_attributes(&quot;/FacetedSearch&quot;)</span></tt>, except that the path passed to the
FacetedSearch resolver is now <tt class="docutils literal"><span class="pre">/some/other/path</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">get_attributes(&quot;/invalid&quot;)</span></tt>: This invalid path is handled by the Root
resolver, which returns the attributes for a folder, that
<tt class="docutils literal"><span class="pre">get_directory(&quot;/invalid&quot;)</span></tt> will populate with an error message.</p>
<p><tt class="docutils literal"><span class="pre">get_directory(&quot;/&quot;)</span></tt>: Return directories for all of the valid 1st level
resolvers, such as FacetedSearch.</p>
<p><tt class="docutils literal"><span class="pre">get_directory(&quot;/FacetedSearch&quot;)</span></tt>: Not handled by the Root resolver. As with
the equivalent <tt class="docutils literal"><span class="pre">get_attributes()</span></tt> call, the path is actually the root for the
FacetedSearch resolver.</p>
<p><tt class="docutils literal"><span class="pre">get_directory(&quot;/FacetedSearch/some/other/path&quot;)</span></tt>: Same as
<tt class="docutils literal"><span class="pre">get_directory(&quot;/FacetedSearch&quot;)</span></tt>, except that the path passed to the
FacetedSearch is now <tt class="docutils literal"><span class="pre">/some/other/path</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">get_directory(&quot;/invalid&quot;)</span></tt>: Because the corresponding <tt class="docutils literal"><span class="pre">get_attributes()</span></tt>
call returned this as a valid folder, the Root resolver now has the chance to
handle the folder and will use it for returning an error message as a folder
that contains a single file, where the name of the file is the error message.</p>
</div>
</div>
<div class="section" id="command-processor">
<h2>3.4. Command processor<a class="headerlink" href="#command-processor" title="Permalink to this headline">¶</a></h2>
<p>To retrieve lists of files and folders for display in the filesystem, the
resolvers issue commands to the Command processor. The Command processor
transforms the commands into one or more queries against the DataONE Solr index
and the DataONE infrastructure and wraps up the results.</p>
</div>
<div class="section" id="path-representation">
<h2>3.5. Path representation<a class="headerlink" href="#path-representation" title="Permalink to this headline">¶</a></h2>
<p>Only the driver specific part of ONEDrive handles paths as strings. The bulk
of the code handles paths as lists of path elements. The elements are strings
or Unicode. They do not contain any escaped characters. The elements may contain
characters that have special meaning in the filesystem, such as the path
separator character (&#8220;/&#8221; on <a href="#id1"><span class="problematic" id="id2">*</span></a>nix). If so, these characters do NOT have the
special meaning that they would have in a normal path string. When joining
the segments together to a path string, the special characters would be
escaped.</p>
<p>Normally, when splitting the root path, &#8220;/&#8221;, one ends up with a list of two
empty strings. The first empty string shows that the path is absolute (starting
at root), and the second that there is nothing after root. In ONEDrive, all
paths represented as lists of path segments are assumed to be rooted, so the
first, empty, element is removed.</p>
</div>
<div class="section" id="searching-in-the-onedrive-filesystem">
<h2>3.6. Searching in the ONEDrive filesystem<a class="headerlink" href="#searching-in-the-onedrive-filesystem" title="Permalink to this headline">¶</a></h2>
<p>Currently, a recursive search in the ONEDrive filesystem, such as with the
&#8220;find&#8221; command in Unix, will cause Solr queries to be performed against the CN
for each possible permutation of facet names and values. There is an &#8220;infinite&#8221;
number of permutations, so this process will never finish.</p>
<p>If a recursive search that also examines file contents is performed, ONEDrive
will in addition attempt to download all objects in DataONE.</p>
<p>It may be necessary to add a system to detect this type of search in ONEDrive
and abort the process.</p>
</div>
<div class="section" id="callbacks">
<h2>3.7. Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h2>
<p>The FUSE callbacks and how these are handled.</p>
<div class="section" id="getattr">
<h3>3.7.1. getattr()<a class="headerlink" href="#getattr" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">getattr()</span></tt> gets called on any path that the user attempts to access and any
path that has previously been returned by <tt class="docutils literal"><span class="pre">readdir()</span></tt>. <tt class="docutils literal"><span class="pre">getattr()</span></tt> returns
information, such as size, date and type, for a single item. In ONEDrive, the
type of an item is either a file or a folder.</p>
<p>ONEDrive handles <tt class="docutils literal"><span class="pre">getattr()</span></tt> calls as follows:</p>
<ol class="arabic simple">
<li>The keys in the attribute cache are searched for a match to the path. If a
match is found, the attributes for the file or folder are returned.</li>
<li>If the path was not found in the cache, <tt class="docutils literal"><span class="pre">get_attributes()</span></tt> is called in the
root resolver. The resolver hierarchy will always return valid attributes due
to <a class="reference internal" href="#returning-error-messages"><em>the way error messages are returned by ONEDrive</em></a>.</li>
<li><tt class="docutils literal"><span class="pre">getattr()</span></tt> caches the result, then returns it.</li>
</ol>
</div>
<div class="section" id="readdir">
<h3>3.7.2. readdir()<a class="headerlink" href="#readdir" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">readdir()</span></tt> is only called for folders. It returns the names of items in a
folder. It does not return any other information, such as the type of the item.
FUSE calls <tt class="docutils literal"><span class="pre">getattr()</span></tt> for each of the items returned by <tt class="docutils literal"><span class="pre">readdir()</span></tt> to get
their type, size and other information.</p>
<p>FUSE assumes that the root, &#8220;/&#8221;, is a folder, so <tt class="docutils literal"><span class="pre">getattr()</span></tt> is not called for
the root before <tt class="docutils literal"><span class="pre">readdir()</span></tt> is called on the root. This is the only exception
to the general pattern of interactions between <cite>getattr()</cite> and <cite>readdir()</cite>.</p>
<p>By calling <tt class="docutils literal"><span class="pre">getattr()</span></tt> and <tt class="docutils literal"><span class="pre">readdir()</span></tt> in a cyclic pattern, FUSE recursively
discovers the folder tree in the filesystem, the contents of the folders, and
the sizes of both files and folders.</p>
<p>FUSE only calls <tt class="docutils literal"><span class="pre">readdir()</span></tt> on folders that were previously designated as
folders and valid paths by <tt class="docutils literal"><span class="pre">getattr()</span></tt>.</p>
<p>ONEDrive handles <tt class="docutils literal"><span class="pre">readdir()</span></tt> calls as follows:</p>
<ol class="arabic simple">
<li>The keys in the directory cache (see <a class="reference internal" href="#readdir">readdir()</a>) are searched for a match
to the path. If a match is found, the names of the contents for the folder
are returned.</li>
<li><tt class="docutils literal"><span class="pre">get_directory()</span></tt> in the root resolver is called. Because
<tt class="docutils literal"><span class="pre">get_attributes()</span></tt> will designate invalid paths as folders,
<tt class="docutils literal"><span class="pre">get_directory()</span></tt> will also be called with those invalid paths. This is for
the purpose of <a class="reference internal" href="#returning-error-messages"><em>returning error messages</em></a>.
So, <tt class="docutils literal"><span class="pre">get_directory()</span></tt> will never return a filesystem error. It may,
however, return folders containing error information. The error information
will be one of two types. The first type is in response to an invalid path
and the second is for internal errors, such as a failure in querying Solr.</li>
<li><tt class="docutils literal"><span class="pre">readdir()</span></tt> caches the result in the directory cache and returns it to
FUSE.</li>
</ol>
</div>
</div>
<div class="section" id="returning-error-messages">
<span id="id3"></span><h2>3.8. Returning error messages<a class="headerlink" href="#returning-error-messages" title="Permalink to this headline">¶</a></h2>
<p>Because ONEDrive applies semantics to sections of paths, it is useful to be able
to provide error messages that are more descriptive than the errors usually
provided by filesystems, such as &#8220;No such file or directory&#8221;. The infrastructure
that the operating system provides for filesystems does not include a way to
return free text error messages, as errors are returned as predefined error
codes. To work around this, ONEDrive renders an error as a folder which contains
a single file, where the name of the file is the error message. This works as
follows:</p>
<p>For all paths except the root, discovery of the filesystem structure that is
provided by ONEDrive starts by a call to <a class="reference internal" href="#getattr">getattr()</a>. In a normal filesystem,
without semantics in the path, the initial call to <tt class="docutils literal"><span class="pre">getattr()</span></tt> would directly
return an error code if the path was not valid. The error code would be resolved
to an error message and displayed to the user, for instance as a popup message.
In ONEDrive, the error message is not returned as an error code. Instead,
<tt class="docutils literal"><span class="pre">getattr()</span></tt> returns a stat structure telling FUSE and the OS that the requested
(invalid) path is a valid folder. FUSE will then call back into ONEDrive via the
<tt class="docutils literal"><span class="pre">readdir()</span></tt> callback to get the contents of the directory. ONEDrive then
returns, as the contents of that directory, a single file, which filename is the
error message.</p>
<p>In a later version of ONEDrive, this mechanism can be expanded so that the error
message file can be opened to provide further details about the error and
suggestions on how to proceed.</p>
</div>
<div class="section" id="debugging">
<h2>3.9. Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>When first mounting ONEDrive, the filesystem will be hit with various automated
requests in order for the OS to learn about the filesystem. This causes trouble
when debugging. On Ubuntu, the automated requests can be disabled temporarily by
killing the gvfs processes:</p>
<div class="highlight-python"><pre>$ sudo pkill -9 -f gvfs</pre>
</div>
</div>
<div class="section" id="index">
<h2>3.10. Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="setup.html">1. Setup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="setup.html#fusepy">1.1. fusepy</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>4. Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="setup.html" title="1. Setup"
             >next</a> |</li>
        <li class="right" >
          <a href="run.html" title="2. Launching ONEDrive"
             >previous</a> |</li>
        <li><a href="index.html">ONEDrive 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010,2011 Participating institutions in DataONE.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>