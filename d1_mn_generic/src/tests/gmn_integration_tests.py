#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This work was created by participants in the DataONE project, and is
# jointly copyrighted by participating institutions in DataONE. For
# more information on DataONE, see our web site at http://dataone.org.
#
#   Copyright ${year}
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''
:mod:`gmn_integration_tests`
============================

:Synopsis:
  Integration testing of ITK and GMN.
  
:Warning:
  This test deletes any existing objects and event log records on the
  destination GMN instance.

:Details:  
  This test works by first putting the target GMN into a known state by deleting
  any existing objects and all event logs from the instance and then creating a
  set of test objects of which all object properties and exact contents are
  known. For each object, a set of fictitious events are stored in the event
  log. The test then runs through a series of tests where the GMN is queried,
  through the ITK, about all aspects of the object collection and the associated
  events and the results are compared with the known correct responses.

  GMN can handle storage of the object bytes itself ("managed" mode), or it can
  defer storage of the object bytes to another web server ("wrapped" mode). The
  mode is selectable on a per object basis. This test tests both managed and
  wrapped modes by running through all the tests twice, first registering the
  objects in managed mode and then in wrapped mode. For the wrapped mode tests
  to work, the test objects must be available on a web server. The location can
  be specified as a program argument.
  
:Created: 2010-06-14
:Author: DataONE (Dahl)
'''

# Stdlib.
import codecs
import datetime
import dateutil
import glob
import hashlib
import httplib
import json
import logging
import optparse
import os
import pprint
import random
import re
import stat
import StringIO
import sys
import time
import unittest2
import urllib
import urlparse
import uuid
import xml.parsers.expat
from xml.sax.saxutils import escape

# D1.
import d1_client
import d1_client.mnclient
import d1_client.systemmetadata
import d1_common.const
import d1_common.types.exceptions
import d1_common.types.generated.dataoneTypes as dataoneTypes
import d1_common.util
import d1_common.date_time
import d1_common.url
import d1_common.xml_compare

# App.
import gmn_test_client

# Constants.

# Test objects.
OBJECTS_TOTAL_DATA = 100
OBJECTS_UNIQUE_DATES = 99
OBJECTS_UNIQUE_DATE_AND_FORMAT_EML = 99
OBJECTS_PID_STARTSWITH_F = 3
OBJECTS_UNIQUE_DATE_AND_PID_STARTSWITH_F = 2
OBJECTS_CREATED_IN_90S = 32

# Event log.
#
# EVENTS_TOTAL is also the number of records in the test_log.csv file. Note:
# Because the tests themselves cause events to be generated, EVENTS_TOTAL is
# only correct just after the events have been injected. For the same reason,
# the other event counts include events that have been generated by the tests up
# to that point.
EVENTS_TOTAL_DATA = 554
EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S = 117
EVENTS_DELETES_UNI_TIME_IN_1990S = 20

EVENTS_TOTAL = 452
EVENTS_TOTAL_EVENT_TOTAL_NO_FILTER = EVENTS_TOTAL + 102
EVENTS_TOTAL_EVENT_TOTAL_TIME_FORMAT = EVENTS_TOTAL + 102
EVENTS_TOTAL_EVENT_UNI_TIME_FROM_1980 = 336
EVENTS_TOTAL_EVENT_UNI_TIME_TO_1990 = 335
EVENTS_READ = 198
EVENTS_UNIQUE_DATES = 351
EVENTS_UNIQUE_DATES_WITH_READ = 96
EVENTS_WITH_OBJECT_FORMAT_EML = 351
EVENTS_COUNT_OF_FIRST = 1

# Access control.
AUTH_PUBLIC_OBJECTS = 12
AUTH_SPECIFIC_USER = 'singing.3369'
AUTH_SPECIFIC_USER_OWNS = 19
AUTH_SPECIFIC_AND_OBJ_FORMAT = 19


def log_setup():
  # Set up logging.
  # We output everything to both file and stdout.
  logging.getLogger('').setLevel(logging.DEBUG)
  formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s', '%y/%m/%d %H:%M:%S')
  file_logger = logging.FileHandler(os.path.splitext(__file__)[0] + '.log', 'a')
  file_logger.setFormatter(formatter)
  logging.getLogger('').addHandler(file_logger)
  console_logger = logging.StreamHandler(sys.stdout)
  console_logger.setFormatter(formatter)
  logging.getLogger('').addHandler(console_logger)

class GMNException(Exception):
  pass

class TestSequenceFunctions(unittest2.TestCase):
  def __init__(self, methodName='runTest'):
    unittest2.TestCase.__init__(self, methodName)
    # Copy docstrings from the tests that are being called so that the unit
    # test framework can display the strings.
    for member_name in dir(self):
      member_obj = getattr(self, member_name)
      if callable(getattr(self, member_name)):
        m = re.match(r'test_\d{4}_(managed|wrapped)_(.*)', member_obj.__name__)
        if m:
          fb = getattr(self, m.group(2))
          try:
            member_obj.__func__.__doc__ = \
              m.group(1)[0].upper() + m.group(1)[1:] + ': ' + fb.__doc__
          except TypeError:
            raise Exception('Missing docstring in {0}'.format(
              member_obj.__name__))

  def setUp(self):
    pass

  def assert_object_list_slice(self, object_list, start, count, total):
    self.assertEqual(object_list.start, start)
    self.assertEqual(object_list.count, count)
    self.assertEqual(object_list.total, total)
    # Check that the actual number of objects matches the count
    # provided in the slice.
    self.assertEqual(len(object_list.objectInfo), count)

  def assert_log_slice(self, log, start, count, total):
    self.assertEqual(log.start, start)
    self.assertEqual(log.count, count)
    self.assertEqual(log.total, total)
    # Check that the actual number of log records matches the count
    # provided in the slice.
    self.assertEqual(len(log.logEntry), count)

  def assert_response_headers(self, response):
    '''Required response headers are present.
    '''

    self.assertIn('Last-Modified', response)
    self.assertIn('Content-Length', response)
    self.assertIn('Content-Type', response)

  def assert_valid_date(self, date_str):
    self.assertTrue(datetime.datetime(*map(int, date_str.split('-'))))

  def find_valid_pid(self, client):
    '''Find the PID of an object that exists on the server.
    '''
    # Verify that there's at least one object on server.
    object_list = client.listObjects(
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertTrue(object_list.count > 0, 'No objects to perform test on')
    # Get the first PID listed. The list is in random order.
    return object_list.objectInfo[0].identifier.value()

#  def generate_sysmeta(self, pid, size, md5, now, owner):
#    return u'''<?xml version="1.0" encoding="UTF-8"?>
#<D1:systemMetadata xmlns:D1="http://ns.dataone.org/service/types/v1">
#  <identifier>{0}</identifier>
#  <objectFormat>eml://ecoinformatics.org/eml-2.0.0</objectFormat>
#  <size>{1}</size>
#  <submitter>{2}</submitter>
#  <rightsHolder>{2}</rightsHolder>
#  <checksum algorithm="MD5">{3}</checksum>
#  <dateUploaded>{4}</dateUploaded>
#  <dateSysMetadataModified>{4}</dateSysMetadataModified>
#  <originMemberNode>MN1</originMemberNode>
#  <authoritativeMemberNode>MN1</authoritativeMemberNode>
#</D1:systemMetadata>
#'''.format(escape(pid), size, owner, md5, datetime.datetime.isoformat(now))

  def generate_sysmeta(self, pid, size, md5, now, owner):
    sysmeta = dataoneTypes.systemMetadata()
    sysmeta.serialVersion = 1
    sysmeta.identifier = pid
    sysmeta.formatId = 'eml://ecoinformatics.org/eml-2.0.0'
    sysmeta.size = size
    sysmeta.submitter = owner
    sysmeta.rightsHolder = owner
    sysmeta.checksum = dataoneTypes.checksum(md5)
    sysmeta.checksum.algorithm = 'MD5'
    sysmeta.dateUploaded = now
    sysmeta.dateSysMetadataModified = now
    sysmeta.originMemberNode = 'MN1'
    sysmeta.authoritativeMemberNode = 'MN1'
    return sysmeta


  def generate_access_policy(self, access_rules):
    accessPolicy = dataoneTypes.accessPolicy()
    for access_rule in access_rules:
      accessRule = dataoneTypes.AccessRule()
      for subject in access_rule[0]:
        accessRule.subject.append(subject)
      for permission in access_rule[1]:
        permission_pyxb = dataoneTypes.Permission(permission)
        accessRule.permission.append(permission_pyxb)
      #accessRule.resource.append('<dummy. field will be removed>')
      accessPolicy.append(accessRule)
    return accessPolicy


  def generate_test_object(self, pid):
    '''Generate a random, small, SciObj / SysMeta pair'''
    # Create a small test object containing only the pid. 
    sciobj = pid.encode('utf-8')
    # Create corresponding System Metadata for the test object.
    size = len(sciobj)
    # hashlib.md5 can't hash a unicode string. If it did, we would get a hash
    # of the internal Python encoding for the string. So we maintain sciobj
    # as a utf-8 string.
    md5 = hashlib.md5(sciobj).hexdigest()
    now = datetime.datetime.now()
    sysmeta = self.generate_sysmeta(pid, size, md5, now,
                                    gmn_test_client.GMN_TEST_SUBJECT_PUBLIC)
    return sciobj, sysmeta


  def session(self, subject):
    session = dataoneTypes.session()
    session.subject = subject
    return {'VENDOR_OVERRIDE_SESSION': session.toxml()}

  # ----------------------------------------------------------------------------
  # Tests that are run for both local and remote objects.
  # ----------------------------------------------------------------------------

  # ----------------------------------------------------------------------------
  # Setup.
  # ----------------------------------------------------------------------------

  def A_delete_all_objects(self):
    '''Delete all objects.'''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.delete_all_objects(
      headers=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def B_object_collection_is_empty(self):
    '''Object collection is empty.'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Get object collection.
    object_list = client.listObjects(
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    # Check header.
    self.assert_object_list_slice(object_list, 0, 0, 0)

  def C_create_objects(self, wrapped=False):
    '''Populate MN with set of test objects.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    for sysmeta_path in sorted(glob.glob(os.path.join(self.options.obj_path,
                                                      '*.sysmeta'))):
      # Get name of corresponding object and open it.
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      object_file = open(object_path, 'r')

      # The pid is stored in the sysmeta.
      sysmeta_file = open(sysmeta_path, 'r')
      sysmeta_xml = sysmeta_file.read()
      sysmeta_obj = dataoneTypes.CreateFromDocument(sysmeta_xml)
      # TODO: Current spec says that rightsHolder should be supplied by
      # client, so we copy the owner in here. I think the spec must be changed
      # to derive this value from the session in the cert.
      #
      sysmeta_obj.rightsHolder = 'test_user_1'

      headers = self.session('test_user_1')

      headers.update({'VENDOR_TEST_OBJECT': 1})

      if wrapped:
        vendor_specific = {
          'VENDOR_GMN_REMOTE_URL': self.options.obj_url + '/' + \
          d1_common.url.encodePathElement(
            d1_common.url.encodePathElement(sysmeta_obj.identifier.value()))
        }
        headers.update(vendor_specific)

      response = client.createResponse(sysmeta_obj.identifier.value(),
                                       object_file, sysmeta_obj,
                                       vendorSpecific=headers)

  def D_object_collection_is_populated(self):
    '''Object collection is populated.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Get object collection.
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    # Check header.
    self.assert_object_list_slice(object_list, 0, OBJECTS_TOTAL_DATA, OBJECTS_TOTAL_DATA)

  def A_delete_event_log(self):
    '''Clear event log.
    '''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.delete_event_log(
      headers=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def B_event_log_is_empty(self):
    '''Event log is empty.
    '''
    '''Object collection is empty.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    logRecords = client.getLogRecords(datetime.datetime(1800, 1, 1))
    self.assertEqual(len(logRecords.logEntry), 0)

  def C_inject_fictional_event_log(self):
    '''Inject a set of fictitious events for each object.
    '''
    csv_file = open('test_log.csv', 'rb')
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.inject_fictional_event_log(csv_file,
      headers=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def D_event_log_is_populated(self):
    '''Event log is populated.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    logRecords = client.getLogRecords(datetime.datetime(1800, 1, 1),
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertEqual(len(logRecords.logEntry), EVENTS_TOTAL)
    found = False
    for o in logRecords.logEntry:
      if o.identifier.value() == 'hdl:10255/dryad.654/mets.xml' \
                                 and o.event == 'create':
        found = True
        break
    self.assertTrue(found)

  def compare_byte_by_byte(self):
    '''Read from MN and do byte-by-byte comparison with local copies.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url, timeout=60)

    for sysmeta_path in sorted(glob.glob(os.path.join(self.options.obj_path,
                                                      '*.sysmeta'))):
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      pid = d1_common.url.decodePathElement(os.path.basename(object_path))
      #sysmeta_xml_disk = open(sysmeta_path, 'r').read()
      object_str_disk = open(object_path, 'rb').read()
      #sysmeta_xml_d1 = client.getSystemMetadata(pid).read()
      object_str_d1 = client.get(pid,
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)) \
        .read(1024 ** 2)
      self.assertEqual(object_str_disk, object_str_d1)

 #Read objectList from MN and compare the values for each object with values
 #from sysmeta on disk.

  def object_properties(self):
    '''Read complete object collection and compare with values stored in local SysMeta files.
    '''
    # Get object collection.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url, timeout=60)
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

    # Loop through our local test objects.
    for sysmeta_path in sorted(glob.glob(os.path.join(self.options.obj_path,
                                                      '*.sysmeta'))):
      # Get name of corresponding object and check that it exists on disk.
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      self.assertTrue(os.path.exists(object_path))
      # Get pid for object.
      pid = d1_common.url.decodePathElement(os.path.basename(object_path))
      # Get sysmeta xml for corresponding object from disk.
      sysmeta_file = open(sysmeta_path, 'rb')
      sysmeta_xml = sysmeta_file.read()
      sysmeta_obj = dataoneTypes.CreateFromDocument(sysmeta_xml)

      # Get corresponding object from objectList.
      found = False
      for object_info in object_list.objectInfo:
        if object_info.identifier.value() == sysmeta_obj.identifier.value():
          found = True
          break;

      self.assertTrue(found,
        'Couldn\'t find object with pid "{0}"'.format(sysmeta_obj.identifier))

      self.assertEqual(object_info.identifier.value(),
                       sysmeta_obj.identifier.value(), sysmeta_path)
      self.assertEqual(object_info.formatId,
                       sysmeta_obj.formatId, sysmeta_path)
      self.assertEqual(object_info.dateSysMetadataModified,
                       sysmeta_obj.dateSysMetadataModified, sysmeta_path)
      self.assertEqual(object_info.size, sysmeta_obj.size, sysmeta_path)
      self.assertEqual(object_info.checksum.value(),
                       sysmeta_obj.checksum.value(), sysmeta_path)
      self.assertEqual(object_info.checksum.algorithm,
                       sysmeta_obj.checksum.algorithm, sysmeta_path)


#  def update_sysmeta(self):
#    '''Update System Metadata.
#    '''
#    pid = '12Cpaup.txt'
#    
#    # Generate a new System Metadata object with Access Policy.
#    sysmeta = self.generate_sysmeta(pid, 123, 'baadf00d',
#                                    datetime.datetime(1976, 7, 8),
#                                    gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
#
#    access_policy_spec = (
#      (('test_user_1',), ('read',)),
#      (('test_user_2',), ('read',))
#    )
#
#    sysmeta.accessPolicy = self.generate_access_policy(access_policy_spec)
#
#    sysmeta.rightsHolder = 'test_user_1'
#
#    # Serialize System Metadata to XML.
#    sysmeta_xml = sysmeta.toxml()
#    mime_multipart_files = [
#      ('sysmeta','systemmetadata.abc', sysmeta_xml.encode('utf-8')),
#    ]
#
#    # POST to /meta/pid.
#    test_update_sysmeta_url = urlparse.urljoin('/v1/meta/',
#      d1_common.url.encodePathElement(pid))
#    
#    root = gmn_test_client.GMNTestClient(self.options.gmn_url)
#    response = root.POST(
#      test_update_sysmeta_url, files=mime_multipart_files,
#      headers=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
#    self.assertEqual(response.status, 200)

#  def object_update(self):
#    '''Update an object.
#    '''
#    # New object.
#    # SysMeta
#    sysmeta_file = 'hdl%3A10255%2Fdryad.669%2Fmets.xml.sysmeta'
#    sysmeta_path = os.path.join(self.options.obj_path, sysmeta_file)
#    sysmeta_xml = open(sysmeta_path, 'rb').read()
#    # SciData
#    object_path = os.path.splitext(sysmeta_path)[0]
#    object_str = open(object_path, 'rb')
#    object_str = ''
#    for i in range(10 * 1024 * 1024):
#      object_str += 'a'
#    object_str += 'z'
#    # 
#    obsoleted_pid = 'AnserMatrix.htm'
#    new_pid = 'update_object_pid'
#    # Update.
#    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
#    response = client.updateResponse(obsoleted_pid,
#                                     object_str, new_pid, sysmeta_xml,
#                                     vendorSpecific=self.session('test_user_1'))
#    return response

  # ----------------------------------------------------------------------------
  # listObjects
  # ----------------------------------------------------------------------------

  def get_object_count(self):
    '''listObjects: Get object count.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(start=0, count=0,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0, 0, OBJECTS_TOTAL_DATA)

  def slicing_1(self):
    '''listObjects: Slicing: Starting at 0 and getting half of the available objects.
    '''
    object_cnt_half = OBJECTS_TOTAL_DATA / 2
    # Starting at 0 and getting half of the available objects.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(start=0, count=object_cnt_half,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0, object_cnt_half,
                       OBJECTS_TOTAL_DATA)

  def slicing_2(self):
    '''listObjects: Slicing: Starting at object_cnt_half and requesting more objects
    than there are.
    '''
    object_cnt_half = OBJECTS_TOTAL_DATA / 2
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(start=object_cnt_half,
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, object_cnt_half, object_cnt_half,
                       OBJECTS_TOTAL_DATA)

  def slicing_3(self):
    '''listObjects: Slicing: Starting above number of objects that we have.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(start=OBJECTS_TOTAL_DATA * 2, count=1,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, OBJECTS_TOTAL_DATA * 2, 0,
                       OBJECTS_TOTAL_DATA)

  def slicing_4(self):
    '''listObjects: Slicing: Requesting more than MAX_LISTOBJECTS should throw.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_cnt_half = OBJECTS_TOTAL_DATA / 2
    self.assertRaises(Exception, client.listObjects,
      count=d1_common.const.MAX_LISTOBJECTS + 1,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def date_range_1(self):
    '''listObjects: Date range query: Get all objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      startTime=datetime.datetime(1990, 1, 1),
      endTime=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0,
                       OBJECTS_CREATED_IN_90S, OBJECTS_CREATED_IN_90S)


  def date_range_2(self):
    '''listObjects: Date range query: Get first 10 objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(start=0, count=10,
      startTime=datetime.datetime(1990, 1, 1),
      endTime=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0, 10, OBJECTS_CREATED_IN_90S)

  def date_range_3(self):
    '''listObjects: Date range query: Get 10 first objects from the 1990s, filtered by objectFormat.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(start=0, count=10,
      startTime=datetime.datetime(1990, 1, 1),
      endTime=datetime.datetime(1999, 12, 31),
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0, 10, OBJECTS_CREATED_IN_90S)

  def date_range_4(self):
    '''listObjects: Date range query: Get 10 first objects from non-existing date range.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(start=0, count=10,
      startTime=datetime.datetime(2500, 1, 1),
      endTime=datetime.datetime(2500, 12, 31),
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_object_list_slice(object_list, 0, 0, 0)

  # ----------------------------------------------------------------------------
  # getLogRecords()
  # ----------------------------------------------------------------------------

  def event_log_get_object_count(self):
    '''getLogRecords: Get event count
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=0, count=0,
      fromDate=datetime.datetime(1800, 1, 1),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, 0, EVENTS_TOTAL_DATA)

  def event_log_slicing_1(self):
    '''getLogRecords: Slicing: Starting at 0 and getting half of the available objects.
    '''
    object_cnt_half = EVENTS_TOTAL_DATA / 2
    # Starting at 0 and getting half of the available objects.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=0, count=object_cnt_half,
      fromDate=datetime.datetime(1800, 1, 1),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, object_cnt_half, EVENTS_TOTAL_DATA)

  def event_log_slicing_2(self):
    '''getLogRecords: Slicing: Starting at object_cnt_half and requesting more objects
    than there are.
    '''
    object_cnt_half = EVENTS_TOTAL_DATA / 2
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=object_cnt_half,
      fromDate=datetime.datetime(1800, 1, 1),
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, object_cnt_half, object_cnt_half,
                       EVENTS_TOTAL_DATA)

  def event_log_slicing_3(self):
    '''getLogRecords: Slicing: Starting above number of objects that we have.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=EVENTS_TOTAL_DATA * 2, count=1,
      fromDate=datetime.datetime(1800, 1, 1),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, EVENTS_TOTAL_DATA * 2, 0,
                       EVENTS_TOTAL_DATA)

  def event_log_slicing_4(self):
    '''getLogRecords: Slicing: Requesting more than MAX_LISTOBJECTS should throw.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_cnt_half = EVENTS_TOTAL_DATA / 2
    self.assertRaises(Exception, client.getLogRecords,
      count=d1_common.const.MAX_LISTOBJECTS + 1,
      fromDate=datetime.datetime(1800, 1, 1),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def event_log_date_range_1(self):
    '''getLogRecords: Date range query: Get all events from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    log = client.getLogRecords(count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S,
                          EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S)


  def event_log_date_range_2(self):
    '''getLogRecords: Date range query: Get first 10 objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=0, count=10,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, 10, EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S)

  def event_log_date_range_3(self):
    '''getLogRecords: Date range query: Get all events from the 1990s, filtered by event type.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(start=0, count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      event='delete',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, EVENTS_DELETES_UNI_TIME_IN_1990S,
                          EVENTS_DELETES_UNI_TIME_IN_1990S)

  def event_log_date_range_4(self):
    '''getLogRecords: Date range query: Get 10 first events from non-existing date range.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    log = client.getLogRecords(start=0, count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(2500, 1, 1),
      toDate=datetime.datetime(2500, 12, 31),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assert_log_slice(log, 0, 0, 0)

  # ----------------------------------------------------------------------------
  # getChecksum()
  # ----------------------------------------------------------------------------

  def get_checksum_test(self, pid, checksum, algorithm):
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    checksum_obj = client.getChecksum(pid, checksumAlgorithm=algorithm,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertTrue(isinstance(checksum_obj, dataoneTypes.Checksum))
    self.assertEqual(checksum, checksum_obj.value())
    self.assertEqual(algorithm, checksum_obj.algorithm)


  def get_checksum_1(self):
    '''getChecksum(): MD5'''
    pid = 'Drugeffect.xls'
    checksum = '916a377112e3d4ed5812f8493a271966'
    algorithm = 'MD5'
    self.get_checksum_test(pid, checksum, algorithm)


  def get_checksum_2(self):
    '''getChecksum(): SHA-1'''
    pid = 'emerson.app'
    checksum = '20b95b4c68c949f1a373efd3a4d612557d8e49b1'
    algorithm = 'SHA-1'
    self.get_checksum_test(pid, checksum, algorithm)


  def get_checksum_3(self):
    '''getChecksum(): Unsupported algorithm returns InvalidRequest exception'''
    pid = 'FigS2_Hsieh.pdf'
    algorithm = 'INVALID_ALGORITHM'
    self.assertRaises(d1_common.types.exceptions.InvalidRequest,
                      self.get_checksum_test, pid, '', algorithm)


  def get_checksum_4(self):
    '''getChecksum(): Non-existing object raises NotFound exception'''
    pid = 'non-existing-pid'
    algorithm = 'MD5'
    self.assertRaises(d1_common.types.exceptions.NotFound,
                      self.get_checksum_test, pid, '', algorithm)


  # ----------------------------------------------------------------------------
  # systemMetadataChanged
  # ----------------------------------------------------------------------------

  def system_metadata_changed_invalid_pid(self):
    '''systemMetadataChanged fails when called with invalid PID'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(d1_common.types.exceptions.NotFound,
      client.systemMetadataChanged, '_bogus_pid_', 1,
        d1_common.date_time.utc_now(),
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))


  def system_metadata_changed_valid_pid(self):
    '''systemMetadataChanged succeeds when called with valid PID'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.systemMetadataChanged('fitch2.mc', 1, d1_common.date_time.utc_now(),
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))


  def system_metadata_changed_valid_pid_invalid_subject(self):
    '''systemMetadataChanged denies access to subjects other that CNs'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(d1_common.types.exceptions.NotAuthorized,
      client.systemMetadataChanged, 'fitch2.mc', 1,
        d1_common.date_time.utc_now(),
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_PUBLIC))

  # ----------------------------------------------------------------------------
  # synchronizationFailed
  # ----------------------------------------------------------------------------

  def synchronization_failed(self):
    '''synchronizationFailed returns 200 OK.
    '''
    # This test does not test if GMN actually does anything with the message
    # passed to the synchronizationFailed() method. There is no way for the
    # test to reach that information.
    pid = '12Cpaup.txt'
    msg = 'TEST MESSAGE FROM GMN_INTEGRATION_TESTER'
    exception = d1_common.types.exceptions.SynchronizationFailed(0, msg, pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.synchronizationFailed(pid, exception,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  # ----------------------------------------------------------------------------
  # /object/<pid>
  # ----------------------------------------------------------------------------

  def get_object_by_invalid_pid(self):
    '''404 NotFound when attempting to get non-existing object /object/_invalid_pid_.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(d1_common.types.exceptions.NotFound, client.get,
                      '_invalid_pid_')

  def get_object_by_valid_pid(self):
    '''Successful retrieval of valid object
    /object/valid_pid.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    response = client.get('10Dappend2.txt',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    # Todo: Verify that we got the right object.

  # Todo: Unicode tests.
  #def test_rest_call_object_by_pid_get_unicode(self):
  #  curl -X GET -H "Accept: application/json" http://127.0.0.1:8000/mn/object/unicode_document_%C7%8E%C7%8F%C7%90%C7%91%C7%92%C7%94%C7%95%C7%96%C7%97%C7%98%C7%99%C7%9A%C7%9B
  #  ?pid=*ǎǏǐǑǒǔǕǖǗǘǙǚǛ

  # /meta/<pid>

  def get_sysmeta_by_invalid_pid(self):
    '''404 NotFound when attempting to get non-existing SysMeta /meta/_invalid_pid_.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(d1_common.types.exceptions.NotFound,
      client.getSystemMetadata,
      '_invalid_pid_',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))


  def get_sysmeta_by_valid_pid(self):
    '''Successful retrieval of valid object /meta/valid_pid.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    response = client.getSystemMetadata('10Dappend2.txt',
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertTrue(response)

  # ----------------------------------------------------------------------------
  # Misc.
  # ----------------------------------------------------------------------------

  def delete(self):
    '''MN_crud.delete() in GMN and libraries.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Find the PID for a random object that exists on the server.
    pid = self.find_valid_pid(client)
    # Delete the object on GMN.
    pid_deleted = client.delete(pid)
    self.assertEqual(pid, pid_deleted.value())
    # Verify that the object no longer exists.
    # We check for SyntaxError raised by the XML deserializer when it attempts
    # to deserialize a DataONEException. The exception is caused by the body
    # being empty since describe() uses a HEAD request.
    self.assertRaises(SyntaxError, client.describe, pid)

  def describe(self):
    '''MN_crud.describe in GMN and libraries.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Find the PID for a random object that exists on the server.
    pid = self.find_valid_pid(client)
    # Get header information for object.
    info = client.describe(pid,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertTrue(re.search(r'dataone-formatid', str(info)))
    self.assertTrue(re.search(r'content-length', str(info)))
    self.assertTrue(re.search(r'last-modified', str(info)))
    self.assertTrue(re.search(r'dataone-checksum', str(info)))


  def replication_known_pid(self):
    '''MNReplication.replicate(): Request to replicate existing object raises IdentifierNotUnique'''
    known_pid = 'AnserMatrix.htm'
    self.assertRaises(d1_common.types.exceptions.IdentifierNotUnique,
                      self.replication, known_pid)


  def replication_unknown_pid(self):
    '''MNReplication.replicate(): Request to replicate new object returns 200 OK'''
    new_pid = 'boguspid'
    self.replication(new_pid)


  def replication(self, pid):
    '''MNReplication.replicate(): Check for correct response.
    Does NOT check if GMN acts on the request and actually performs the replication.
    '''
    scidata, sysmeta = self.generate_test_object(pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    #source_node = dataoneTypes.nodeReference('test_source_node')
    source_node = 'test_source_node'
    success = client.replicate(sysmeta, source_node,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertTrue(success)


  def unicode_test_1(self):
    '''GMN and libraries handle Unicode correctly.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
#    test_doc_path = os.path.join(self.options.int_path,
#                                 'src', 'test', 'resources', 'd1_testdocs',
#                                 'encodingTestSet')
#    test_ascii_strings_path = os.path.join(test_doc_path,
#                                           'testAsciiStrings.utf8.txt')
    test_ascii_strings_path = './tricky_identifiers_unicode.txt'
    file_obj = codecs.open(test_ascii_strings_path, 'rb', 'utf-8')
    for line in file_obj:
      line = line.strip()
      try:
        pid_unescaped, pid_escaped = line.split('\t')
      except ValueError:
        continue
      scidata, sysmeta = self.generate_test_object(pid_unescaped)
      # Create the object on GMN.
      client.create(pid_unescaped, StringIO.StringIO(scidata), sysmeta,
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
      # Retrieve the object from GMN.
      scidata_retrieved = client.get(pid_unescaped,
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))\
          .read()
      sysmeta_obj_retrieved = client.getSystemMetadata(pid_unescaped,
        vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
      # Round-trip validation.
      self.assertEqual(scidata_retrieved, scidata)
      self.assertEqual(sysmeta_obj_retrieved.identifier.value()\
                       .encode('utf-8'), scidata)


  def auth_listobjects_1(self):
    '''listObjects returns all objects when called by trusted user.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
    self.assertEqual(object_list.count, OBJECTS_TOTAL_DATA)

  def auth_listobjects_2(self):
    '''listObjects returns only public objects when called by public user.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(gmn_test_client.GMN_TEST_SUBJECT_PUBLIC))
    self.assertEqual(object_list.count, AUTH_PUBLIC_OBJECTS)

  def auth_listobjects_3(self):
    '''listObjects returns only public objects when called by unknown user.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session('unknown user'))
    self.assertEqual(object_list.count, AUTH_PUBLIC_OBJECTS)

  def auth_listobjects_4(self):
    '''listObjects returns only public + specific user's objects
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.session(AUTH_SPECIFIC_USER))
    self.assertEqual(object_list.count, AUTH_SPECIFIC_USER_OWNS)

  def auth_listobjects_5(self):
    '''listObjects: slicing + specific user
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=5,
      vendorSpecific=self.session(AUTH_SPECIFIC_USER))
    self.assert_object_list_slice(object_list, 0, 5, AUTH_SPECIFIC_USER_OWNS)

  def auth_listobjects_6(self):
    '''listObjects: slicing + specific user + objectFormat
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(count=5,
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.session(AUTH_SPECIFIC_USER))
    self.assert_object_list_slice(object_list, 0, 5, AUTH_SPECIFIC_AND_OBJ_FORMAT)


  #
  # Tests.
  #

  # The tests are defined manually instead of dynamically because they
  # describe the order in which the tests should be run and they can
  # be easilly commented out here when debugging.
  #

  #
  # Managed (object byte storage handled locally by GMN).
  #

  def test_1010_managed_A_delete_all_objects(self):
    self.A_delete_all_objects()

  def test_1010_managed_B_object_collection_is_empty(self):
    self.B_object_collection_is_empty()

  def test_1010_managed_C_create_objects(self):
    self.C_create_objects()

  def test_1010_managed_D_object_collection_is_populated(self):
    self.D_object_collection_is_populated()

  def test_1020_managed_A_delete_event_log(self):
    self.A_delete_event_log()

  def test_1020_managed_B_event_log_is_empty(self):
    self.B_event_log_is_empty()

  def test_1020_managed_C_inject_fictional_event_log(self):
    self.C_inject_fictional_event_log()

  def test_1020_managed_D_event_log_is_populated(self):
    self.D_event_log_is_populated()

  def test_1030_managed_compare_byte_by_byte(self):
    self.compare_byte_by_byte()

  def test_1040_managed_object_properties(self):
    self.object_properties()

#  def test_1050_managed_object_update(self):
#    self.object_update()

#  def test_1060_managed_update_sysmeta(self):
#    self.update_sysmeta()

  def test_1100_managed_get_object_count(self):
    self.get_object_count()

  def test_1105_managed_slicing_1(self):
    self.slicing_1()

  def test_1110_managed_slicing_2(self):
    self.slicing_2()

  def test_1120_managed_slicing_3(self):
    self.slicing_3()

  def test_1130_managed_slicing_4(self):
    self.slicing_4()

  def test_1140_managed_date_range_1(self):
    self.date_range_1()

  def test_1150_managed_date_range_2(self):
    self.date_range_2()

  def test_1160_managed_date_range_3(self):
    self.date_range_3()

  def test_1170_managed_date_range_4(self):
    self.date_range_4()

  def test_1190_managed_get_object_by_invalid_pid(self):
    self.get_object_by_invalid_pid()

  def test_1200_managed_get_object_by_valid_pid(self):
    self.get_object_by_valid_pid()

  def test_1210_managed_get_sysmeta_by_invalid_pid(self):
    self.get_sysmeta_by_invalid_pid()

  def test_1220_managed_get_sysmeta_by_valid_pid(self):
    self.get_sysmeta_by_valid_pid()

  def test_1231_managed_event_log_get_object_count(self):
    self.event_log_get_object_count()

  def test_1232_managed_event_log_slicing_1(self):
    self.event_log_slicing_1()

  def test_1233_managed_event_log_slicing_2(self):
    self.event_log_slicing_2()

  def test_1234_managed_event_log_slicing_3(self):
    self.event_log_slicing_3()

  def test_1235_managed_event_log_slicing_4(self):
    self.event_log_slicing_4()

  def test_1236_managed_event_log_date_range_1(self):
    self.event_log_date_range_1()

  def test_1237_managed_event_log_date_range_2(self):
    self.event_log_date_range_2()

  def test_1238_managed_event_log_date_range_3(self):
    self.event_log_date_range_3()

  def test_1239_managed_event_log_date_range_4(self):
    self.event_log_date_range_4()

  def test_1250_managed_get_checksum_1(self):
    self.get_checksum_1()

  def test_1251_managed_get_checksum_2(self):
    self.get_checksum_2()

  def test_1252_managed_get_checksum_3(self):
    self.get_checksum_3()

  def test_1253_managed_get_checksum_4(self):
    self.get_checksum_4()

#  def test_1330_managed_delete(self):
#    self.delete()
#
  def test_1340_managed_describe(self):
    self.describe()

  def test_1360_managed_unicode_test_1(self):
    self.unicode_test_1()

  def test_1380_managed_system_metadata_changed_invalid_pid(self):
    self.system_metadata_changed_invalid_pid()

  def test_1381_managed_system_metadata_changed_valid_pid(self):
    self.system_metadata_changed_valid_pid()

  def test_1382_managed_system_metadata_changed_valid_pid_invalid_subject(self):
    self.system_metadata_changed_valid_pid_invalid_subject()

  def test_1400_managed_synchronization_failed(self):
    self.synchronization_failed()

  def test_1500_managed_replication_known_pid(self):
    self.replication_known_pid()

  def test_1510_managed_replication_unknown_pid(self):
    self.replication_unknown_pid()

  #
  # Wrapped (object bytes store by remote web server).
  #

  def test_2010_wrapped_A_delete_all_objects(self):
    self.A_delete_all_objects()

  def test_2010_wrapped_B_object_collection_is_empty(self):
    self.B_object_collection_is_empty()

  def test_2010_wrapped_C_create_objects(self):
    # This test requires the objects to also be available on a web server
    # (http://localhost:80/test_client_objects by default). This simulates
    # remote storage of the objects.
    self.C_create_objects(wrapped=True)

  def test_2010_wrapped_D_object_collection_is_populated(self):
    self.D_object_collection_is_populated()

  def test_2020_wrapped_A_delete_event_log(self):
    self.A_delete_event_log()

  def test_2020_wrapped_B_event_log_is_empty(self):
    self.B_event_log_is_empty()

  def test_2020_wrapped_C_inject_fictional_event_log(self):
    self.C_inject_fictional_event_log()

  def test_2020_wrapped_D_event_log_is_populated(self):
    self.D_event_log_is_populated()

  def test_2030_wrapped_compare_byte_by_byte(self):
    self.compare_byte_by_byte()

  def test_2040_wrapped_object_properties(self):
    self.object_properties()

#  def test_2050_wrapped_object_update(self):
#    self.object_update()

#  def test_2060_wrapped_update_sysmeta(self):
#    self.update_sysmeta()

  def test_2100_wrapped_get_object_count(self):
    self.get_object_count()

  def test_2105_wrapped_slicing_1(self):
    self.slicing_1()

  def test_2110_wrapped_slicing_2(self):
    self.slicing_2()

  def test_2120_wrapped_slicing_3(self):
    self.slicing_3()

  def test_2130_wrapped_slicing_4(self):
    self.slicing_4()

  def test_2140_wrapped_date_range_1(self):
    self.date_range_1()

  def test_2150_wrapped_date_range_2(self):
    self.date_range_2()

  def test_2160_wrapped_date_range_3(self):
    self.date_range_3()

  def test_2170_wrapped_date_range_4(self):
    self.date_range_4()

  def test_2190_wrapped_get_object_by_invalid_pid(self):
    self.get_object_by_invalid_pid()

  def test_2200_wrapped_get_object_by_valid_pid(self):
    self.get_object_by_valid_pid()

  def test_2210_wrapped_get_sysmeta_by_invalid_pid(self):
    self.get_sysmeta_by_invalid_pid()

  def test_2220_wrapped_get_sysmeta_by_valid_pid(self):
    self.get_sysmeta_by_valid_pid()

  def test_2231_wrapped_event_log_get_object_count(self):
    self.event_log_get_object_count()

  def test_2232_wrapped_event_log_slicing_1(self):
    self.event_log_slicing_1()

  def test_2233_wrapped_event_log_slicing_2(self):
    self.event_log_slicing_2()

  def test_2234_wrapped_event_log_slicing_3(self):
    self.event_log_slicing_3()

  def test_2235_wrapped_event_log_slicing_4(self):
    self.event_log_slicing_4()

  def test_2236_wrapped_event_log_date_range_1(self):
    self.event_log_date_range_1()

  def test_2237_wrapped_event_log_date_range_2(self):
    self.event_log_date_range_2()

  def test_2238_wrapped_event_log_date_range_3(self):
    self.event_log_date_range_3()

  def test_2239_wrapped_event_log_date_range_4(self):
    self.event_log_date_range_4()

  def test_2250_wrapped_get_checksum_1(self):
    self.get_checksum_1()

  def test_2251_wrapped_get_checksum_2(self):
    self.get_checksum_2()

  def test_2252_wrapped_get_checksum_3(self):
    self.get_checksum_3()

  def test_2253_wrapped_get_checksum_4(self):
    self.get_checksum_4()

#  def test_2330_wrapped_delete(self):
#    self.delete_test()
#
  def test_2340_wrapped_describe(self):
    self.describe()

  def test_2360_wrapped_unicode_test_1(self):
    self.unicode_test_1()

  def test_2380_wrapped_system_metadata_changed_invalid_pid(self):
    self.system_metadata_changed_invalid_pid()

  def test_2381_wrapped_system_metadata_changed_valid_pid(self):
    self.system_metadata_changed_valid_pid()

  def test_2382_wrapped_system_metadata_changed_valid_pid_invalid_subject(self):
    self.system_metadata_changed_valid_pid_invalid_subject()

  def test_2400_wrapped_synchronization_failed(self):
    self.synchronization_failed()

  def test_2500_wrapped_replication_known_pid(self):
    self.replication_known_pid()

  def test_2510_wrapped_replication_unknown_pid(self):
    self.replication_unknown_pid()



def main():
  log_setup()

  # Command line options.
  parser = optparse.OptionParser()
  parser.add_option('--d1-root', dest='d1_root', action='store', type='string', default='http://0.0.0.0:8000/cn/') # default=d1_common.const.URL_DATAONE_ROOT
  parser.add_option('--gmn-url', dest='gmn_url', action='store', type='string', default='http://0.0.0.0:8000')
  parser.add_option('--gmn2-url', dest='gmn2_url', action='store', type='string', default='http://0.0.0.0:8001/')
  parser.add_option('--gmn-replicate-src-ref', dest='replicate_src_ref', action='store', type='string', default='gmn_dryad')
  parser.add_option('--cn-url', dest='cn_url', action='store', type='string', default='http://cn-dev.dataone.org/cn/')
  parser.add_option('--xsd-path', dest='xsd_url', action='store', type='string', default='http://129.24.0.11/systemmetadata.xsd')
  parser.add_option('--obj-path', dest='obj_path', action='store', type='string', default='./test_objects')
  parser.add_option('--obj-url', dest='obj_url', action='store', type='string', default='http://localhost/test_objects/')
  parser.add_option('--verbose', action='store_true', default=False, dest='verbose')
  parser.add_option('--quick', action='store_true', default=False, dest='quick')
  parser.add_option('--test', action='store', default='', dest='test', help='run a single test')
#  parser.add_option('--unicode-path', dest='unicode_path', action='store', type='string', default='/home/dahl/D1/svn/allsoftware/cicore/d1_integration/src/test/resources/d1_testdocs/encodingTestSet/testUnicodeStrings.utf8.txt')
  parser.add_option('--integration-path', dest='int_path', action='store', type='string', default='./d1_integration')
  parser.add_option('--debug', action='store_true', default=False, dest='debug')

  (options, args) = parser.parse_args()

  if not options.verbose:
    logging.getLogger('').setLevel(logging.ERROR)

  s = TestSequenceFunctions
  s.options = options

  if options.test != '':
    suite = unittest2.TestSuite(map(s, [options.test]))
    #suite.debug()
  else:
    suite = unittest2.TestLoader().loadTestsFromTestCase(s)

#  if options.debug == True:    
#    unittest2.TextTestRunner(verbosity=2).debug(suite)
#  else:
  unittest2.TextTestRunner(verbosity=2, failfast=True).run(suite)

if __name__ == '__main__':
  main()

