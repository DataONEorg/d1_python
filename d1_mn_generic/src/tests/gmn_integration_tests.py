#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This work was created by participants in the DataONE project, and is
# jointly copyrighted by participating institutions in DataONE. For
# more information on DataONE, see our web site at http://dataone.org.
#
#   Copyright 2009-2012 DataONE
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
'''
:mod:`gmn_integration_tests`
============================

:Synopsis:
  Integration testing of ITK and GMN.

:Warning:
  This test deletes any existing objects and event log records on the
  destination GMN instance. For the tests to be able to run, ALLOW_UNIT_TESTS
  must be set to True in the settings_site.py file of the GMN instance being
  tested.

:Details:
  This test works by first putting the target GMN into a known state by deleting
  any existing objects and all event logs from the instance and then creating a
  set of test objects of which all object properties and exact contents are
  known. For each object, a set of fictitious events are stored in the event
  log. The test then runs through a series of tests where the GMN is queried,
  through the ITK, about all aspects of the object collection and the associated
  events and the results are compared with the known correct responses.

  GMN can handle storage of the object bytes itself ("managed" mode), or it can
  defer storage of the object bytes to another web server ("wrapped" mode). The
  mode is selectable on a per object basis. This test tests managed mode by
  default and can be set to test wrapped by specifying the --wrapped flag on
  the command line. For the wrapped mode tests to work, the test objects must be
  available on a web server. The location can be specified as a program
  argument.

:Created: 2010-06-14
:Author: DataONE (Dahl)
'''

# Stdlib.
import codecs
import datetime
#import dateutil
import glob
import hashlib
#import httplib
#import json
import logging
import optparse
import os
#import pprint
#import random
import re
#import stat
import StringIO
import sys
#import time
import unittest
#import urllib
#import urlparse
#import uuid
#import xml.parsers.expat
#from xml.sax.saxutils import escape

# D1.
#import d1_client
import d1_client.mnclient
#import d1_client.systemmetadata
import d1_common.const
import d1_common.types.exceptions
import d1_common.types.generated.dataoneTypes as dataoneTypes
#import d1_common.util
import d1_common.date_time
import d1_common.url
#import d1_common.xml_compare

# App.
import gmn_test_client

# Constants.

# Test objects.
OBJECTS_TOTAL_DATA = 100
OBJECTS_UNIQUE_DATES = 99
OBJECTS_UNIQUE_DATE_AND_FORMAT_EML = 99
OBJECTS_PID_STARTSWITH_F = 3
OBJECTS_UNIQUE_DATE_AND_PID_STARTSWITH_F = 2
OBJECTS_CREATED_IN_90S = 32

# Event log.
#
# EVENTS_TOTAL is the number of records in the test_log.csv file. Because the
# tests themselves cause events to be generated, EVENTS_TOTAL is only correct
# just after the events have been injected. For the same reason, the other event
# counts include events that have been generated by the tests up to that point.
EVENTS_TOTAL = 452
EVENTS_TOTAL_1500 = EVENTS_TOTAL + 103
EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S = 117
EVENTS_DELETES_UNI_TIME_IN_1990S = 20

# Access control.
AUTH_PUBLIC_OBJECTS = 12
AUTH_SPECIFIC_USER = 'singing.3369'
AUTH_SPECIFIC_USER_OWNS = 19
AUTH_SPECIFIC_AND_OBJ_FORMAT = 19


class GMNIntegrationTests(unittest.TestCase):
  def setUp(self):
    pass

  def assert_object_list_slice(self, object_list, start, count, total):
  def tearDown(self):
    """The integration tests typically target a local instance of GMN where
    Django debug mode is enabled (DEBUG = True in settings_site.py). In this
    mode, an unhandled exception in GMN will cause Django to return an
    interactive diagnostics HTML page that is useful for debugging.

    If the server responds with something that cannot be parsed by libclient as
    a valid response for the particular call, libclient raises a DataONE
    ServiceFailure exception with the response stored in the traceInformation
    member. The Django diagnostics page triggers this behavior, so, in order to
    access the diagnostics page, we check for unhandled DataONEExceptions here
    and write any provided traceInformation to files to temporary storage,
    typically /tmp.

    For convenience, we also maintain a link to the latest failure. Together
    with the "--stop" parameter for Nose, it allows just refreshing the browser
    to view new errors as they occur.

    When serializing a DataONEException to a string, traceInformation is
    truncated to 1024 characters, but the files written here will always contain
    the complete traceInformation.
    """
    exc_type, exc_value, exc_traceback = sys.exc_info()
    if isinstance(exc_value, d1_common.types.exceptions.DataONEException):
      if exc_value.traceInformation:
        func_name = traceback.extract_tb(exc_traceback)[1][2]
        file_path = os.path.join(
          tempfile.gettempdir(), u'traceInformation_{}'.format(func_name)
        )
        with open(file_path, 'w') as f:
          f.write(exc_value.traceInformation.encode('utf8'))
        link_path = os.path.join(
          tempfile.gettempdir(), u'traceInformation.html'
        )
        self._force_symlink(file_path, link_path)
        logging.warning(u'Wrote traceInformation to {}'.format(file_path))

  def _force_symlink(self, file_path, link_path):
    try:
      os.remove(link_path)
    except OSError as e:
      if e.errno != errno.ENOENT:
        raise
    os.symlink(file_path, link_path)

    self.assertEqual(object_list.start, start)
    self.assertEqual(object_list.count, count)
    self.assertEqual(object_list.total, total)
    # Check that the actual number of objects matches the count
    # provided in the slice.
    self.assertEqual(len(object_list.objectInfo), count)

  def assert_log_slice(self, log, start, count, total):
    self.assertEqual(log.start, start)
    self.assertEqual(log.count, count)
    self.assertEqual(log.total, total)
    # Check that the actual number of log records matches the count
    # provided in the slice.
    self.assertEqual(len(log.logEntry), count)

  def _assert_response_headers(self, response):
    """Required response headers are present.
    """
    self.assertIn('last-modified', response.headers)
    self.assertIn('content-length', response.headers)
    self.assertIn('content-type', response.headers)

  def _assert_valid_date(self, date_str):
    self.assertTrue(datetime.datetime(*map(int, date_str.split('-'))))

  def find_valid_pid(self, client):
    '''Find the PID of an object that exists on the server.
    '''
    # Verify that there's at least one object on server.
    object_list = client.listObjects(
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertTrue(object_list.count > 0, 'No objects to perform test on')
    # Get the first PID listed. The list is in random order.
    return object_list.objectInfo[0].identifier.value()

  def generate_sysmeta(self, pid, size, md5, now, owner):
    sysmeta = dataoneTypes.systemMetadata()
    sysmeta.serialVersion = 1
    sysmeta.identifier = pid
    sysmeta.formatId = 'eml://ecoinformatics.org/eml-2.0.0'
    sysmeta.size = size
    sysmeta.submitter = owner
    sysmeta.rightsHolder = owner
    sysmeta.checksum = dataoneTypes.checksum(md5)
    sysmeta.checksum.algorithm = 'MD5'
    sysmeta.dateUploaded = now
    sysmeta.dateSysMetadataModified = now
    sysmeta.originMemberNode = 'MN1'
    sysmeta.authoritativeMemberNode = 'MN1'
    return sysmeta

  def generate_access_policy(self, access_rules):
    accessPolicy = dataoneTypes.accessPolicy()
    for access_rule in access_rules:
      accessRule = dataoneTypes.AccessRule()
      for subject in access_rule[0]:
        accessRule.subject.append(subject)
      for permission in access_rule[1]:
        permission_pyxb = dataoneTypes.Permission(permission)
        accessRule.permission.append(permission_pyxb)
      accessPolicy.append(accessRule)
    return accessPolicy

  def generate_test_object(self, pid):
    '''Generate a random, small, SciObj / SysMeta pair'''
    # Create a small test object containing only the pid.
    sciobj = pid.encode('utf-8')
    # Create corresponding System Metadata for the test object.
    size = len(sciobj)
    # hashlib.md5 can't hash a Unicode string. If it did, we would get a hash
    # of the internal Python encoding for the string. So we maintain sciobj
    # as a UTF-8 string.
    md5 = hashlib.md5(sciobj).hexdigest()
    now = datetime.datetime.now()
    sysmeta = self.generate_sysmeta(
      pid, size, md5, now, gmn_test_client.GMN_TEST_SUBJECT_PUBLIC
    )
    return sciobj, sysmeta

  def include_subjects(self, subjects):
    if isinstance(subjects, basestring):
      subjects = [subjects]
    return {'VENDOR_INCLUDE_SUBJECTS': '\t'.join(subjects)}

  def has_public_object_list(self):
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    return eval(client.get_setting('PUBLIC_OBJECT_LIST'))

  # ============================================================================
  # Preparation.
  # ============================================================================

  def test_1000_A(self):
    '''GMN must be in debug mode when running unit tests.'''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    self.assertEqual(client.get_setting('GMN_DEBUG'), 'True')

  def test_1000_B(self):
    '''GMN must be set to allow running destructive integration tests.'''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    self.assertEqual(client.get_setting('ALLOW_INTEGRATION_TESTS'), 'True')

  def test_1020_A(self):
    '''Delete all objects.'''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.delete_all_objects(
      headers=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1020_B(self):
    '''Object collection is empty.'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, 0, 0)

  def test_1020_C(self):
    '''Delete all replication requests.'''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.clear_replication_queue(
      headers=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  # ----------------------------------------------------------------------------
  # Set up test objects. Also checks create()
  # ----------------------------------------------------------------------------

  def test_1050_A(self):
    '''Populate MN with set of test objects.
    Uses the internal diagnostics create() and does not test create permissions.
    '''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    for sysmeta_path in sorted(
      glob.glob(os.path.join(self.options.obj_path, '*.sysmeta'))
    ):
      # Get name of corresponding object and open it.
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      object_file = open(object_path, 'r')

      # The pid is stored in the sysmeta.
      sysmeta_file = open(sysmeta_path, 'r')
      sysmeta_xml = sysmeta_file.read()
      sysmeta_obj = dataoneTypes.CreateFromDocument(sysmeta_xml)
      sysmeta_obj.rightsHolder = 'test_user_1'

      headers = self.include_subjects('test_user_1')
      headers.update({'VENDOR_TEST_OBJECT': 1})

      if self.options.wrapped:
        vendor_specific = {
          'VENDOR_GMN_REMOTE_URL': self.options.obj_url + '/' + \
          d1_common.url.encodePathElement(
            d1_common.url.encodePathElement(sysmeta_obj.identifier.value()))
        }
        headers.update(vendor_specific)

      client.create(
        sysmeta_obj.identifier.value(),
        object_file,
        sysmeta_obj,
        vendorSpecific=headers
      )

  def test_1050_B(self):
    '''Object collection is populated.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Get object collection.
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    # Check header.
    self.assert_object_list_slice(object_list, 0, OBJECTS_TOTAL_DATA, OBJECTS_TOTAL_DATA)

  # ----------------------------------------------------------------------------
  # Set up test event log.
  # ----------------------------------------------------------------------------

  def test_1100_A(self):
    '''Clear event log.
    '''
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.delete_event_log(
      headers=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1100_B(self):
    '''Event log is empty.
    '''
    '''Object collection is empty.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    logRecords = client.getLogRecords()
    self.assertEqual(len(logRecords.logEntry), 0)

  def test_1100_C(self):
    '''Inject a set of fictitious events for each object.
    '''
    csv_file = open('test_log.csv', 'rb')
    client = gmn_test_client.GMNTestClient(self.options.gmn_url)
    client.inject_fictional_event_log(
      csv_file,
      headers=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1100_D(self):
    '''Event log is populated.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    logRecords = client.getLogRecords(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertEqual(len(logRecords.logEntry), EVENTS_TOTAL)
    found = False
    for o in logRecords.logEntry:
      if o.identifier.value() == 'hdl:10255/dryad.654/mets.xml' \
                                 and o.event == 'create':
        found = True
        break
    self.assertTrue(found)

  # ============================================================================
  # Read API
  # ============================================================================

  # ----------------------------------------------------------------------------
  # get()
  # ----------------------------------------------------------------------------

  def test_1200(self):
    '''get(): Successful retrieval of valid object.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    response = client.get(
      '10Dappend2.txt',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    headers = response.getheaders()
    self.assertTrue(('content-length', '1982') in headers)
    self.assertTrue(
      ('dataone-checksum', 'MD5,ed387674851ba80bd2d3c6c42f335cf7') in headers
    )
    self.assertTrue(('dataone-formatid', 'eml://ecoinformatics.org/eml-2.0.0') in headers)
    self.assertTrue(('last-modified', '1977-03-09T00:12:05') in headers)
    self.assertTrue(('content-type', 'text/xml') in headers)

  def test_1210(self):
    '''get(): 404 NotFound when attempting to get non-existing object.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(d1_common.types.exceptions.NotFound, client.get, '_invalid_pid_')

  def test_1220(self):
    '''get(): Read from MN and do byte-by-byte comparison with local copies.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url, timeout=60)

    for sysmeta_path in sorted(
      glob.glob(os.path.join(self.options.obj_path, '*.sysmeta'))
    ):
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      pid = d1_common.url.decodePathElement(os.path.basename(object_path))
      #sysmeta_xml_disk = open(sysmeta_path, 'r').read()
      object_str_disk = open(object_path, 'rb').read()
      #sysmeta_xml_d1 = client.getSystemMetadata(pid).read()
      object_str_d1 = client.get(pid,
        vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)) \
        .read(1024 ** 2)
      self.assertEqual(object_str_disk, object_str_d1)

  # ----------------------------------------------------------------------------
  # getSystemMetadata()
  # ----------------------------------------------------------------------------

  def test_1250(self):
    '''getSystemMetadata(): Successful retrieval of SysMeta of valid object.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    response = client.getSystemMetadata(
      '10Dappend2.txt',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertTrue(response)

  def test_1260(self):
    '''getSystemMetadata(): 404 NotFound when attempting to get non-existing SysMeta.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.NotFound,
      client.getSystemMetadata,
      '_invalid_pid_',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  # ----------------------------------------------------------------------------
  # describe()
  # ----------------------------------------------------------------------------

  def test_1290(self):
    '''MNStorage.describe(): Returns valid header for valid object.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Find the PID for a random object that exists on the server.
    pid = self.find_valid_pid(client)
    # Get header information for object.
    info = client.describe(
      pid,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertTrue(re.search(r'dataone-formatid', str(info)))
    self.assertTrue(re.search(r'content-length', str(info)))
    self.assertTrue(re.search(r'last-modified', str(info)))
    self.assertTrue(re.search(r'dataone-checksum', str(info)))

  # ----------------------------------------------------------------------------
  # listObjects()
  # ----------------------------------------------------------------------------

  def test_1300(self):
    '''listObjects(): Read complete object collection and compare with values stored in local SysMeta files.
    '''
    # Get object collection.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url, timeout=60)
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

    # Loop through our local test objects.
    for sysmeta_path in sorted(
      glob.glob(os.path.join(self.options.obj_path, '*.sysmeta'))
    ):
      # Get name of corresponding object and check that it exists on disk.
      object_path = re.match(r'(.*)\.sysmeta', sysmeta_path).group(1)
      self.assertTrue(os.path.exists(object_path))
      # Get pid for object.
      pid = d1_common.url.decodePathElement(os.path.basename(object_path))
      # Get sysmeta xml for corresponding object from disk.
      sysmeta_file = open(sysmeta_path, 'rb')
      sysmeta_xml = sysmeta_file.read()
      sysmeta_obj = dataoneTypes.CreateFromDocument(sysmeta_xml)

      # Get corresponding object from objectList.
      found = False
      for object_info in object_list.objectInfo:
        if object_info.identifier.value() == sysmeta_obj.identifier.value():
          found = True
          break

      self.assertTrue(
        found, 'Couldn\'t find object with pid "{0}"'.format(sysmeta_obj.identifier)
      )

      self.assertEqual(
        object_info.identifier.value(), sysmeta_obj.identifier.value(), sysmeta_path
      )
      self.assertEqual(object_info.formatId, sysmeta_obj.formatId, sysmeta_path)
      self.assertEqual(
        object_info.dateSysMetadataModified, sysmeta_obj.dateSysMetadataModified,
        sysmeta_path
      )
      self.assertEqual(object_info.size, sysmeta_obj.size, sysmeta_path)
      self.assertEqual(
        object_info.checksum.value(), sysmeta_obj.checksum.value(), sysmeta_path
      )
      self.assertEqual(
        object_info.checksum.algorithm, sysmeta_obj.checksum.algorithm, sysmeta_path
      )

  def test_1310(self):
    '''listObjects(): Get object count.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(
      start=0,
      count=0,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, 0, OBJECTS_TOTAL_DATA)

  def test_1320(self):
    '''listObjects(): Slicing: Starting at 0 and getting half of the available objects.
    '''
    object_cnt_half = OBJECTS_TOTAL_DATA / 2
    # Starting at 0 and getting half of the available objects.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      start=0,
      count=object_cnt_half,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, object_cnt_half, OBJECTS_TOTAL_DATA)

  def test_1330(self):
    '''listObjects(): Slicing: Starting at object_cnt_half and requesting more objects
    than there are.
    '''
    object_cnt_half = OBJECTS_TOTAL_DATA / 2
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      start=object_cnt_half,
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(
      object_list, object_cnt_half, object_cnt_half, OBJECTS_TOTAL_DATA
    )

  def test_1340(self):
    '''listObjects(): Slicing: Starting above number of objects that we have.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      start=OBJECTS_TOTAL_DATA * 2,
      count=1,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(
      object_list, OBJECTS_TOTAL_DATA * 2, 0, OBJECTS_TOTAL_DATA
    )

  def test_1360(self):
    '''listObjects(): Date range query: Get all objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(
      object_list, 0, OBJECTS_CREATED_IN_90S, OBJECTS_CREATED_IN_90S
    )

  def test_1370(self):
    '''listObjects(): Date range query: Get first 10 objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(
      start=0,
      count=10,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, 10, OBJECTS_CREATED_IN_90S)

  def test_1380(self):
    '''listObjects(): Date range query: Get 10 first objects from the 1990s, filtered by objectFormat.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(
      start=0,
      count=10,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, 10, OBJECTS_CREATED_IN_90S)

  def test_1390(self):
    '''listObjects(): Date range query: Get 10 first objects from non-existing date range.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    object_list = client.listObjects(
      start=0,
      count=10,
      fromDate=datetime.datetime(2500, 1, 1),
      toDate=datetime.datetime(2500, 12, 31),
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_object_list_slice(object_list, 0, 0, 0)

  def test_1400(self):
    '''listObjects(): Returns all objects when called by trusted user.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertEqual(object_list.count, OBJECTS_TOTAL_DATA)

  def test_1410(self):
    '''listObjects(): Returns only public objects when called by public user.
    '''
    # This test can only run if public access has been enabled for listObjects.
    if not self.has_public_object_list():
      return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_PUBLIC)
    )
    self.assertEqual(object_list.count, AUTH_PUBLIC_OBJECTS)

  def test_1420(self):
    '''listObjects(): Returns only public objects when called by unknown user.
    '''
    # This test can only run if public access has been enabled for listObjects.
    if not self.has_public_object_list():
      return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects('unknown user')
    )
    self.assertEqual(object_list.count, AUTH_PUBLIC_OBJECTS)

  def test_1430(self):
    '''listObjects(): returns only public + specific user's objects
    '''
    # This test can only run if public access has been enabled for listObjects.
    if not self.has_public_object_list():
      return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(AUTH_SPECIFIC_USER)
    )
    self.assertEqual(object_list.count, AUTH_SPECIFIC_USER_OWNS)

  def test_1440(self):
    '''listObjects(): slicing + specific user
    '''
    # This test can only run if public access has been enabled for listObjects.
    if not self.has_public_object_list():
      return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=5, vendorSpecific=self.include_subjects(AUTH_SPECIFIC_USER)
    )
    self.assert_object_list_slice(object_list, 0, 5, AUTH_SPECIFIC_USER_OWNS)

  def test_1450(self):
    '''listObjects(): slicing + specific user + objectFormat
    '''
    # This test can only run if public access has been enabled for listObjects.
    if not self.has_public_object_list():
      return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    object_list = client.listObjects(
      count=5,
      objectFormat='eml://ecoinformatics.org/eml-2.0.0',
      vendorSpecific=self.include_subjects(AUTH_SPECIFIC_USER)
    )
    self.assert_object_list_slice(object_list, 0, 5, AUTH_SPECIFIC_AND_OBJ_FORMAT)

  # ----------------------------------------------------------------------------
  # getLogRecords()
  # ----------------------------------------------------------------------------

  def test_1500(self):
    '''getLogRecords(): Get event count
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=0,
      count=0,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(log, 0, 0, EVENTS_TOTAL_1500)

  def test_1510(self):
    '''getLogRecords(): Slicing: Starting at 0 and getting half of the available events.
    '''
    object_cnt_half = EVENTS_TOTAL / 2
    # Starting at 0 and getting half of the available objects.
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=0,
      count=object_cnt_half,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(log, 0, object_cnt_half, EVENTS_TOTAL_1500)

  def test_1520(self):
    '''getLogRecords(): Slicing: From center and more than are available
    '''
    object_cnt_half = EVENTS_TOTAL_1500 / 2
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=object_cnt_half,
      count=d1_common.const.MAX_LISTOBJECTS,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(
      log, object_cnt_half, EVENTS_TOTAL_1500 - object_cnt_half, EVENTS_TOTAL_1500
    )

  def test_1530(self):
    '''getLogRecords(): Slicing: Starting above number of events that are available.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=EVENTS_TOTAL_1500 * 2,
      count=1,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(log, EVENTS_TOTAL_1500 * 2, 0, EVENTS_TOTAL_1500)

  def test_1550(self):
    '''getLogRecords(): Date range query: Get all events from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    log = client.getLogRecords(
      count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(
      log, 0, EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S, EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S
    )

  def test_1560(self):
    '''getLogRecords(): Date range query: Get first 10 objects from the 1990s.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=0,
      count=10,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(log, 0, 10, EVENTS_TOTAL_EVENT_UNI_TIME_IN_1990S)

  def test_1570(self):
    '''getLogRecords(): Date range query: Get all events from the 1990s, filtered by event type.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    log = client.getLogRecords(
      start=0,
      count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(1990, 1, 1),
      toDate=datetime.datetime(1999, 12, 31),
      event='delete',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(
      log, 0, EVENTS_DELETES_UNI_TIME_IN_1990S, EVENTS_DELETES_UNI_TIME_IN_1990S
    )

  def test_1580(self):
    '''getLogRecords(): Date range query: Get 10 first events from non-existing date range.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)

    log = client.getLogRecords(
      start=0,
      count=d1_common.const.MAX_LISTOBJECTS,
      fromDate=datetime.datetime(2500, 1, 1),
      toDate=datetime.datetime(2500, 12, 31),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assert_log_slice(log, 0, 0, 0)

  # ----------------------------------------------------------------------------
  # getChecksum()
  # ----------------------------------------------------------------------------

  def _get_checksum_test(self, pid, checksum, algorithm):
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    checksum_obj = client.getChecksum(
      pid,
      checksumAlgorithm=algorithm,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertTrue(isinstance(checksum_obj, dataoneTypes.Checksum))
    self.assertEqual(checksum, checksum_obj.value())
    self.assertEqual(algorithm, checksum_obj.algorithm)

  def test_1600(self):
    '''getChecksum(): MD5'''
    pid = 'Drugeffect.xls'
    checksum = '916a377112e3d4ed5812f8493a271966'
    algorithm = 'MD5'
    self._get_checksum_test(pid, checksum, algorithm)

  def test_1610(self):
    '''getChecksum(): SHA-1'''
    pid = 'emerson.app'
    checksum = '20b95b4c68c949f1a373efd3a4d612557d8e49b1'
    algorithm = 'SHA-1'
    self._get_checksum_test(pid, checksum, algorithm)

  def test_1620(self):
    '''getChecksum(): Unsupported algorithm returns InvalidRequest exception'''
    pid = 'FigS2_Hsieh.pdf'
    algorithm = 'INVALID_ALGORITHM'
    self.assertRaises(
      d1_common.types.exceptions.InvalidRequest, self._get_checksum_test, pid, '',
      algorithm
    )

  def test_1630(self):
    '''getChecksum(): Non-existing object raises NotFound exception'''
    pid = 'non-existing-pid'
    algorithm = 'MD5'
    self.assertRaises(
      d1_common.types.exceptions.NotFound, self._get_checksum_test, pid, '', algorithm
    )

  # ----------------------------------------------------------------------------
  # systemMetadataChanged()
  # ----------------------------------------------------------------------------

  def test_1700(self):
    '''systemMetadataChanged(): fails when called with invalid PID'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.NotFound,
      client.systemMetadataChanged,
      '_bogus_pid_',
      1,
      d1_common.date_time.utc_now(),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1710(self):
    '''systemMetadataChanged(): succeeds when called with valid PID'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.systemMetadataChanged(
      'fitch2.mc',
      1,
      d1_common.date_time.utc_now(),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1720(self):
    '''systemMetadataChanged(): denies access to subjects other that CNs'''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.NotAuthorized,
      client.systemMetadataChanged,
      'fitch2.mc',
      1,
      d1_common.date_time.utc_now(),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_PUBLIC)
    )

  # ----------------------------------------------------------------------------
  # synchronizationFailed()
  # ----------------------------------------------------------------------------

  def test_1800(self):
    '''MNRead.synchronizationFailed() with valid error returns 200 OK.
    '''
    # This test does not test if GMN actually does anything with the message
    # passed to the synchronizationFailed() method. There is currently no way
    # for the test to reach that information.
    pid = '12Cpaup.txt'
    msg = 'TEST MESSAGE FROM GMN_INTEGRATION_TESTER'
    exception = d1_common.types.exceptions.SynchronizationFailed(0, msg, pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.synchronizationFailed(
      exception,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1810(self):
    '''MNRead.synchronizationFailed() from untrusted subject raises NotAuthorized.
    '''
    pid = '12Cpaup.txt'
    msg = 'TEST MESSAGE FROM GMN_INTEGRATION_TESTER'
    exception = d1_common.types.exceptions.SynchronizationFailed(0, msg, pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.NotAuthorized, client.synchronizationFailed, exception
    )

# Disabled because, in v1, InvalidRequest is not a valid response for
# MNRead.synchronizationFailed(). MNRead.synchronizationFailed() must return
# a 200 OK even if there is an issue with the call.
#   def test_1820(self):
#     '''MNRead.synchronizationFailed() with invalid XML document raises InvalidRequest.
#     '''
#     class InvalidException():
#       def serialize(self):
#         return 'INVALID SERIALIZED DATAONE EXCEPTION'
#
#     client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
#     self.assertRaises(d1_common.types.exceptions.InvalidRequest,
#                       client.synchronizationFailed,
#                       InvalidException(),
#                       vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))

  def test_1830(self):
    '''MNRead.synchronizationFailed() with invalid XML document returns 200 OK.
    '''

    class InvalidException():
      def serialize(self):
        return 'INVALID SERIALIZED DATAONE EXCEPTION'

    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    print client.synchronizationFailed(
      InvalidException(),
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

# ============================================================================
# Misc.
# ============================================================================

# ----------------------------------------------------------------------------
# node
# ----------------------------------------------------------------------------

  def test_1850(self):
    '''MNCore.getCapabilities(): Returns a valid Node Registry document.
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    node = client.getCapabilities()
    self.assertTrue(isinstance(node, dataoneTypes.Node))

  def _generate_identifier(self):
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    fragment = 'test_fragment'
    identifier = client.generateIdentifier('UUID', fragment)
    self.assertTrue(identifier.value().startswith(fragment))
    self.assertTrue(len(identifier.value()) > len(fragment))
    return identifier.value()

  def test_1860_A(self):
    '''MNStorage.generateIdentifier(): Returns a valid identifier that matches scheme and fragment'''
    self._generate_identifier()

  def test_1860_B(self):
    '''MNStorage.generateIdentifier(): Returns a different, valid identifier when called second time'''
    pid1 = self._generate_identifier()
    pid2 = self._generate_identifier()
    self.assertNotEqual(pid1, pid2)

  # ----------------------------------------------------------------------------
  # MNReplication.replicate()
  # ----------------------------------------------------------------------------

  def test_1900(self):
    '''MNReplication.replicate(): Request to replicate new object returns 200 OK.
    Does NOT check if GMN acts on the request and actually performs the replication.
    '''
    known_pid = 'new_pid'
    scidata, sysmeta = self.generate_test_object(known_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.replicate(
      sysmeta,
      'test_source_node',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1910(self):
    '''MNReplication.replicate(): Request to replicate existing object raises IdentifierNotUnique.
    Does NOT check if GMN acts on the request and actually performs the replication.
    '''
    known_pid = 'AnserMatrix.htm'
    scidata, sysmeta = self.generate_test_object(known_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.IdentifierNotUnique,
      client.replicate,
      sysmeta,
      'test_source_node',
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )

  def test_1920(self):
    '''MNReplication.replicate(): Request from non-trusted subject returns NotAuthorized.
    Does NOT check if GMN acts on the request and actually performs the replication.
    '''
    known_pid = 'new_pid_2'
    scidata, sysmeta = self.generate_test_object(known_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.NotAuthorized, client.replicate, sysmeta,
      'test_source_node'
    )

  # ----------------------------------------------------------------------------
  # MNStorage.update()
  # ----------------------------------------------------------------------------

  #  def test_2000(self):
  #    '''Update System Metadata.
  #    '''
  #    pid = '12Cpaup.txt'
  #
  #    # Generate a new System Metadata object with Access Policy.
  #    sysmeta = self.generate_sysmeta(pid, 123, 'baadf00d',
  #                                    datetime.datetime(1976, 7, 8),
  #                                    gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
  #
  #    access_policy_spec = (
  #      (('test_user_1',), ('read',)),
  #      (('test_user_2',), ('read',))
  #    )
  #
  #    sysmeta.accessPolicy = self.generate_access_policy(access_policy_spec)
  #
  #    sysmeta.rightsHolder = 'test_user_1'
  #
  #    # Serialize System Metadata to XML.
  #    sysmeta_xml = sysmeta.toxml()
  #    mime_multipart_files = [
  #      ('sysmeta','systemmetadata.abc', sysmeta_xml.encode('utf-8')),
  #    ]
  #
  #    # POST to /meta/pid.
  #    test_test_1060_update_sysmeta_url = urlparse.urljoin('/v1/meta/',
  #      d1_common.url.encodePathElement(pid))
  #
  #    root = gmn_test_client.GMNTestClient(self.options.gmn_url)
  #    response = root.POST(
  #      test_test_1060_update_sysmeta_url, files=mime_multipart_files,
  #      headers=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))
  #    self.assertEqual(response.status, 200)

  def test_2010_A(self):
    '''MNStorage.update(): Creating a new object that obsoletes another object.
    '''
    new_pid = 'update_object_pid_1'
    old_pid = 'AnserMatrix.htm'
    sci_obj, sys_meta = self.generate_test_object(new_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    client.update(
      old_pid,
      StringIO.StringIO(sci_obj),
      new_pid,
      sys_meta,
      vendorSpecific=self.include_subjects('test_user_1')
    )

  def test_2010_B(self):
    '''MNStorage.update(): Attempt to update an obsoleted object raises InvalidRequest.
    '''
    new_pid = 'update_object_pid_2'
    old_pid = 'AnserMatrix.htm'
    sci_obj, sys_meta = self.generate_test_object(new_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.InvalidRequest,
      client.update,
      old_pid,
      StringIO.StringIO(sci_obj),
      new_pid,
      sys_meta,
      vendorSpecific=self.include_subjects('test_user_1')
    )

  def test_2010_C(self):
    '''MNStorage.update(): Attempt to update an object with existing PID, raises IdentifierNotUnique.
    '''
    new_pid = 'update_object_pid_1'
    old_pid = 'fitch2.mc'
    sci_obj, sys_meta = self.generate_test_object(new_pid)
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    self.assertRaises(
      d1_common.types.exceptions.IdentifierNotUnique,
      client.update,
      old_pid,
      StringIO.StringIO(sci_obj),
      new_pid,
      sys_meta,
      vendorSpecific=self.include_subjects('test_user_1')
    )

  # ----------------------------------------------------------------------------
  # MNStorage.delete()
  # ----------------------------------------------------------------------------

  def test_2100(self):
    '''MNStorage.delete()
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Find the PID for a random object that exists on the server.
    pid = self.find_valid_pid(client)
    # Delete the object on GMN.
    pid_deleted = client.delete(
      pid,
      vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    self.assertEqual(pid, pid_deleted.value())
    # Verify that the object no longer exists.
    self.assertRaises(d1_common.types.exceptions.DataONEException, client.describe, pid)

  # ----------------------------------------------------------------------------
  # MNStorage.archive()
  # ----------------------------------------------------------------------------

  def test_2200_A(self):
    '''MNStorage.archive()
    '''
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    # Find the PID for a random object that exists on the server.
    pid = self.find_valid_pid(client)
    # Archive the object on GMN.
    pid_archived = client.archive(
      pid, vendorSpecific=self.include_subjects('test_user_1')
    )
    self.assertEqual(pid, pid_archived.value())
    # Verify that the object no longer exists.
    self.assertRaises(d1_common.types.exceptions.DataONEException, client.describe, pid)

  # ----------------------------------------------------------------------------
  # Unicode.
  # ----------------------------------------------------------------------------

  def test_2300(self):
    '''Unicode: GMN and libraries handle Unicode correctly.
    '''
    # Many of these do not work when running against the Django development
    # server. This is due to a bug in the development server. Disabled until I
    # add logic to detect development server and skip the identifiers that the
    # development server cannot handle.
    print 'Unicode tests currently disabled. See code for details'
    return
    client = d1_client.mnclient.MemberNodeClient(self.options.gmn_url)
    #    test_doc_path = os.path.join(self.options.int_path,
    #                                 'src', 'test', 'resources', 'd1_testdocs',
    #                                 'encodingTestSet')
    #    test_ascii_strings_path = os.path.join(test_doc_path,
    #                                           'testAsciiStrings.utf8.txt')
    test_ascii_strings_path = './tricky_identifiers_unicode.txt'
    file_obj = codecs.open(test_ascii_strings_path, 'rb', 'utf-8')
    for line in file_obj:
      line = line.strip()
      try:
        pid_unescaped, pid_escaped = line.split('\t')
      except ValueError:
        continue
      scidata, sysmeta = self.generate_test_object(pid_unescaped)
      # Create the object on GMN.
      client.create(
        pid_unescaped,
        StringIO.StringIO(scidata),
        sysmeta,
        vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
      )
      # Retrieve the object from GMN.
      scidata_retrieved = client.get(pid_unescaped,
        vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED))\
          .read()
      sysmeta_obj_retrieved = client.getSystemMetadata(
        pid_unescaped,
        vendorSpecific=self.include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
      )
      # Round-trip validation.
      self.assertEqual(scidata_retrieved, scidata)
      self.assertEqual(sysmeta_obj_retrieved.identifier.value()\
                       .encode('utf-8'), scidata)

  # ----------------------------------------------------------------------------
  # Chains and SIDs
  # ----------------------------------------------------------------------------

  def test_3000_v1(self):
    """MNStorage.create(): Creating a standalone object with new PID and SID
    does not raise exception.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3000(client, v1)

  def test_3000_v2(self):
    """MNStorage.create(): Creating a standalone object with new PID and SID
    does not raise exception.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3000(client, v2)

  def _test_3000(self, client, binding):
    pid = self._random_id()
    sid = self._random_id()
    self._create(client, binding, pid, sid)

  # --

  def test_3010_v1(self):
    """v1 MNStorage.create(): Attempting to reuse existing SID as PID when creating
    a standalone object raises IdentifierNotUnique.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3010(client, v1)

  def test_3010_v2(self):
    """v2 MNStorage.create(): Attempting to reuse existing SID as PID when creating
    a standalone object raises IdentifierNotUnique.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3010(client, v2)

  def _test_3010(self, client, binding):
    pid = self._random_id()
    sid1 = self._random_id()
    sid2 = self._random_id()
    client_v2 = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._create(client_v2, v2, pid, sid1)
    # self._create(client, binding, sid1)
    # self._create(client, binding, sid1)
    self.assertRaises(
      d1_common.types.exceptions.IdentifierNotUnique,
      self._create,
      client,
      binding,
      sid1,
      sid2,
    )

  # --

  def test_3020_v2(self):
    """v2 MNStorage.create(): Attempting to reuse existing SID as SID when creating
    a standalone object raises IdentifierNotUnique. This test is not applicable
    to v1 MNStorage.create() since v1 sysmeta cannot hold a SID.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3020(client, v2)

  def _test_3020(self, client, binding):
    pid1 = self._random_id()
    pid2 = self._random_id()
    sid = self._random_id()
    self._create(client, binding, pid1, sid)
    self.assertRaises(
      d1_common.types.exceptions.IdentifierNotUnique, self._create, client,
      binding, pid1, pid2
    )

  # --

  def test_3030_v1(self):
    """v1 MNStorage.get(): Attempting to pass a SID to v1 get() raises NotFound
    even though the SID exists (by design, we don't resolve SIDs for v1).
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self.assertRaises(
      d1_common.types.exceptions.NotFound,
      self._test_3030, client, v1
    )

  def test_3030_v2(self):
    """v2 MNStorage.get(): Retrieving standalone object by SID resolves to
    correct PID.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3030(client, v2)

  def _test_3030(self, client, binding):
    pid = self._random_id()
    sid = self._random_id()
    create_sci_obj_str, create_sysmeta_obj = self._create(
      client, binding, pid, sid
    )
    get_sci_obj_str, get_sysmeta_obj = self._get(client, sid)
    self.assertEqual(create_sci_obj_str, get_sci_obj_str)
    self.assertEqual(get_sysmeta_obj.identifier.value(), pid)
    self.assertEqual(get_sysmeta_obj.seriesId.value(), sid)

  # --

  def test_3031_v1(self):
    """v1 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletes pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3031(client, v1)

  def test_3031_v2(self):
    """v2 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletes pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3031(client, v2)

  def _test_3031(self, client, binding):
    pid1 = self._random_id()
    sid1 = self._random_id()
    self._create(client, binding, pid1, sid1)
    pid2 = self._random_id()
    sid2 = self._random_id()
    self.assertRaises(
      d1_common.types.exceptions.InvalidSystemMetadata,
      self._create, client, binding, pid2, sid2, obsoletes=pid1
    )

  # --

  def test_3032_v1(self):
    """v1 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletes pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3032(client, v1)

  def test_3032_v2(self):
    """v2 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletes pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3032(client, v2)

  def _test_3032(self, client, binding):
    """MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletes pointing to unknown object raises InvalidSystemMetadata.
    """
    pid = self._random_id()
    sid = self._random_id()
    unknown_pid = self._random_id()
    self.assertRaises(
      d1_common.types.exceptions.InvalidSystemMetadata,
      self._create, client, binding, pid, sid,
      obsoletes=unknown_pid
    )

  # --

  def test_3033_v1(self):
    """v1 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletedBy pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3033(client, v1)

  def test_3033_v2(self):
    """v2 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletedBy pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3033(client, v2)

  def _test_3033(self, client, binding):
    pid1 = self._random_id()
    sid1 = self._random_id()
    self._create(client, binding, pid1, sid1)
    pid2 = self._random_id()
    sid2 = self._random_id()
    self.assertRaises(
      d1_common.types.exceptions.InvalidSystemMetadata,
      self._create, client, binding,
      pid2,
      sid2,
      obsoleted_by=pid1,
    )

  # --

  def test_3034_v1(self):
    """v1 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletedBy pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3034(client, v1)

  def test_3034_v2(self):
    """v2 MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletedBy pointing to known object raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3034(client, v2)

  def _test_3034(self, client, binding):
    """MNStorage.create(): Attempt to create standalone object with
    sysmeta.obsoletedBy pointing to unknown object raises InvalidSystemMetadata.
    """
    pid = self._random_id()
    sid = self._random_id()
    unknown_pid = self._random_id()
    self.assertRaises(
      d1_common.types.exceptions.InvalidSystemMetadata, self._create, client, binding, pid, sid,
      obsoleted_by=unknown_pid
    )

  # Update()

  def test_3040_v1(self):
    """v1 MNStorage.update(): Attempting to update a non-existing object raises
    NotFound.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3040(client, v1)

  def test_3040_v2(self):
    """v2 MNStorage.update(): Attempting to update a non-existing object raises
    NotFound.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3040(client, v2)

  def _test_3040(self, client, binding):
    old_pid = self._random_id()
    new_pid = self._random_id()
    self.assertRaises(
      d1_common.types.exceptions.NotFound, self._update, client, binding, old_pid, new_pid
    )

  # --

  def test_3041_v1(self):
    """v1 MNStorage.update(): Attempting to update an object when sysmeta
    PID does not match URL PID raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3041(client, v1)

  def test_3041_v2(self):
    """v2 MNStorage.update(): Attempting to update an object when sysmeta
    PID does not match URL PID raises InvalidSystemMetadata.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3041(client, v2)

  def _test_3041(self, client, binding):
    # Create valid base obj.
    base_pid = self._random_id()
    self._create(client, binding, base_pid)
    # Attempt update of valid base obj with invalid sysmeta.
    unk_pid = self._random_id()
    update_pid = self._random_id()
    sci_obj_str, sysmeta_obj = self._generate_test_object(binding, unk_pid)
    self.assertRaises(
      d1_common.types.exceptions.InvalidSystemMetadata, client.update, base_pid,
      StringIO.StringIO(sci_obj_str), update_pid, sysmeta_obj,
      vendorSpecific=self.
      _include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    )
    return sci_obj_str, sysmeta_obj

  # --

  def test_3042_v1(self):
    """v1 MNStorage.update(): Attempting to reuse existing PID when updating a
    standalone object raises IdentifierNotUnique.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3042(client, v1)

  def test_3042_v2(self):
    """v2 MNStorage.update(): Attempting to reuse existing PID when updating a
    standalone object raises IdentifierNotUnique.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3042(client, v2)

  def _test_3042(self, client, binding):
    base_pid = self._random_id()
    self._create(client, binding, base_pid)
    self.assertRaises(
      d1_common.types.exceptions.IdentifierNotUnique, self._update, client, binding, base_pid,
      base_pid
    )

  # --

  def test_3043_v1(self):
    """v1 MNStorage.create(), MNStorage.update(): A chain can be created by
    updating a standalone object, when neither objects have a SID.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3043(client, v1)

  def test_3043_v2(self):
    """v2 MNStorage.create(), MNStorage.update(): A chain can be created by
    updating a standalone object, when neither objects have a SID.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3043(client, v2)

  def _test_3043(self, client, binding):
    base_pid = self._random_id()
    update_pid = self._random_id()
    self._create(client, binding, base_pid)
    base_obj_str, base_sysmeta_obj = self._get(client, base_pid)
    self.assertIsNone(base_sysmeta_obj.obsoletes)
    self.assertIsNone(base_sysmeta_obj.obsoletedBy)
    self._update(client, binding, base_pid, update_pid)
    base_obj_str, base_sysmeta_obj = self._get(client, base_pid)
    self.assertIsNone(base_sysmeta_obj.obsoletes)
    self.assertEquals(base_sysmeta_obj.obsoletedBy.value(), update_pid)

  # --

  def test_3050_v1(self):
    """v1 MNStorage.update(): Updating a base object that has a SID without
    specifying a SID in the update causes the SID to shift to the update.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._test_3050(client, v1)

  def test_3050_v2(self):
    """v2 MNStorage.update(): Updating a base object that has a SID without
    specifying a SID in the update causes the SID to shift to the update.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._test_3050(client, v2)

  def _test_3050(self, client, binding):
    # Create base object with SID
    base_pid = self._random_id()
    base_sid = self._random_id()
    client_v2 = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._create(client_v2, v2, base_pid, base_sid)
    base_obj_str, base_sysmeta_obj = self._get(client_v2, base_pid)
    self.assertEquals(base_sysmeta_obj.identifier.value(), base_pid)
    self.assertEquals(base_sysmeta_obj.seriesId.value(), base_sid)
    # Update without SID
    update_pid = self._random_id()
    self._update(client, binding, base_pid, update_pid)
    # Retrieve object by base SID and verify that it's the updated object.
    update_obj_str, update_sysmeta_obj = self._get(client, update_pid)
    self.assertEquals(update_sysmeta_obj.identifier.value(), update_pid)

  #
  # Test wrapped mode
  #

  def _create_and_compare(
    self, client, binding, num_sciobj_bytes, redirect_bool
  ):
    pid = self._random_id()
    created_sciobj_str, created_sysmeta_obj = self._create_wrapped_sciobj_httpbin(
      client, binding, pid, num_sciobj_bytes, redirect_bool=redirect_bool
    )
    retrieved_sciobj_str = client.get(
      pid,
      vendorSpecific=self.
      _include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED),
    ).read()
    retrieved_sysmeta_obj = client.getSystemMetadata(
      pid,
      vendorSpecific=self.
      _include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED),
    )
    self.assertEqual(len(retrieved_sciobj_str), num_sciobj_bytes)
    self.assertEqual(created_sciobj_str, retrieved_sciobj_str)
    self.assertEqual(
      created_sysmeta_obj.checksum.value(),
      retrieved_sysmeta_obj.checksum.value()
    )
    # self._assert_sci_obj_checksum_matches_sysmeta(response, sysmeta_obj)

  def _create_wrapped_sciobj_httpbin(
    self, client, binding, pid, num_sciobj_bytes, redirect_bool
  ):
    """Create a sciobj that wraps object bytes stored on a 3rd party server.
    httpbin.org is used for providing the wrapped object bytes. The bytes
    returned by httpbin are generated by a PRNG which we seed with a hash of the
    PID, causing the same object bytes to always be returned for a given PID.
    If {redirect_bool} is True, a 302 redirect operation is added. To get to the
    object bytes, the client must follow the redirect.
    """
    object_stream_url = self._make_httpbin_url(
      num_sciobj_bytes, pid, redirect_bool
    )
    sciobj_str = self._get_remote_sciobj_bytes(object_stream_url)
    sysmeta_obj = self._generate_sysmeta(
      binding, pid, sciobj_str, gmn_test_client.GMN_TEST_SUBJECT_PUBLIC
    )
    self._create_wrapped_sciobj(client, object_stream_url, sysmeta_obj, pid)
    return sciobj_str, sysmeta_obj

  def _create_wrapped_sciobj(self, client, object_stream_url, sysmeta_obj, pid):
    headers = self._include_subjects(gmn_test_client.GMN_TEST_SUBJECT_TRUSTED)
    headers['VENDOR-GMN-REMOTE-URL'] = object_stream_url
    client.create(pid, '', sysmeta_obj, vendorSpecific=headers)

  def _get_remote_sciobj_bytes(self, sciobj_url):
    r = requests.get(sciobj_url)
    return r.content

  def _make_httpbin_url(self, num_sciobj_bytes, pid, redirect_bool):
    pid_hash_int = int(hashlib.md5(pid).hexdigest(), 16)
    stream_bytes_path = '/stream-bytes/{}?seed={}'.format(
      num_sciobj_bytes, pid_hash_int
    )
    object_stream_url = urlparse.urljoin(HTTPBIN_SERVER_STR, stream_bytes_path)
    if not redirect_bool:
      return object_stream_url
    else:
      redirect_to_object_path = '/redirect-to?{}'.format(
        urllib.urlencode({'url': object_stream_url})
      )
      return urlparse.urljoin(HTTPBIN_SERVER_STR, redirect_to_object_path)

  def _assert_not_retrievable(self, url):
    pid = self._random_id()
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    sysmeta_obj = self._generate_sysmeta(
      v1, pid, pid, gmn_test_client.GMN_TEST_SUBJECT_PUBLIC
    )
    # self._create_wrapped_sciobj(client, url, sysmeta_obj, pid)
    self.assertRaises(
      d1_common.types.exceptions.InvalidRequest,
      self._create_wrapped_sciobj,
      client,
      url,
      sysmeta_obj,
      pid,
    )

  def test_3100_v1(self):
    """v1 Creating wrapped object with URL to unknown domain returns InvalidRequest"""
    self._assert_not_retrievable('http://some-non-existing-domain-2398.com')

  def test_3110_v1(self):
    """v1 Creating wrapped object with URL to 404 returns InvalidRequest"""
    not_found_url = urlparse.urljoin(HTTPBIN_SERVER_STR, '/status/404')
    self._assert_not_retrievable(not_found_url)

  def test_3200_v1(self):
    """v1 Create wrapped sciobj. Object is directly accessible at the given URL.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._create_and_compare(client, v1, 6543, redirect_bool=False)

  def test_3200_v2(self):
    """v2 Create wrapped sciobj. Object is directly accessible at the given URL.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._create_and_compare(client, v2, 6543, redirect_bool=False)

  def test_3210_v1(self):
    """v1 Create wrapped sciobj. Object accessible via 302 Temporary Redirect.
    """
    client = d1_client.mnclient.MemberNodeClient(GMN_URL)
    self._create_and_compare(client, v1, 6543, redirect_bool=True)

  def test_3210_v2(self):
    """v2 Create wrapped sciobj. Object accessible via 302 Temporary Redirect.
    """
    client = d1_client.mnclient_2_0.MemberNodeClient_2_0(GMN_URL)
    self._create_and_compare(client, v2, 6543, redirect_bool=True)


class GMNException(Exception):
  pass
