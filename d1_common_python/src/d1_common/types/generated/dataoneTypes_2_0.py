# ./d1_common/types/generated/dataoneTypes_2_0.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:cdd9555a55a103332598275a87c4a7c1422c46ed
# Generated 2014-08-21 15:14:04.166283 by PyXB version 1.2.3
# Namespace http://ns.dataone.org/service/types/v2.0

import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:13bbda42-2978-11e4-bec1-000c292ff10e')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.3'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import dataoneTypes as _ImportedBinding_dataoneTypes
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.NamespaceForURI(u'http://ns.dataone.org/service/types/v2.0', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, unicode):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Complex type {http://ns.dataone.org/service/types/v2.0}SystemMetadata with content type ELEMENT_ONLY
class SystemMetadata (_ImportedBinding_dataoneTypes.SystemMetadata):
    """ System metadata (often referred to as
	      :term:`sysmeta`) is the information used by DataONE to track and manage
	      objects across the distributed Coordinating and Member Nodes of the
	      network. System metadata documents contain low level information (e.g.
	      size, type, owner, access control rules) about managed objects such as
	      science data, science metadata, and resource map objects and the
	      relationships between objects (e.g. *obsoletes* and
	      *obsoletedBy*). The information is maintained dynamically by
	      Coordinating Nodes and is mutable in that it reflects the current state
	      of an object in the system. Initial properties of system metadata are
	      generated by clients and Member Nodes. After object synchronization, the
	      Coordinating Nodes hold authoritative copies of system metadata. Mirror
	      copies of system metadata are maintained at each of the Coordinating
	      nodes.  System metadata are considered operational
	      information needed to run DataONE, and can be read by all Coordinating
	      Nodes and Member Nodes in the course of service provision. In order to
	      reduce issues with third-party tracking of data status information,
	      users can read system metadata for an object if they have the access
	      rights to read the corresponding object which a system metadata record
	      describes.  System Metadata elements are partitioned into two
	      classes: metadata elements that must be provided by client software to
	      the DataONE system, and elements that are generated by DataONE itself in
	      the course of managing objects. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SystemMetadata')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 75, 1)
    _ElementMap = _ImportedBinding_dataoneTypes.SystemMetadata._ElementMap.copy()
    _AttributeMap = _ImportedBinding_dataoneTypes.SystemMetadata._AttributeMap.copy()
    # Base type is _ImportedBinding_dataoneTypes.SystemMetadata
    
    # Element serialVersion (serialVersion) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element identifier (identifier) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element formatId (formatId) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element size (size) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element checksum (checksum) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element submitter (submitter) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element rightsHolder (rightsHolder) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element accessPolicy (accessPolicy) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element replicationPolicy (replicationPolicy) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element obsoletes (obsoletes) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element obsoletedBy (obsoletedBy) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element archived (archived) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element dateUploaded (dateUploaded) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element dateSysMetadataModified (dateSysMetadataModified) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element originMemberNode (originMemberNode) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element authoritativeMemberNode (authoritativeMemberNode) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element replica (replica) inherited from {http://ns.dataone.org/service/types/v1}SystemMetadata
    
    # Element seriesId uses Python identifier seriesId
    __seriesId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'seriesId'), 'seriesId', '__httpns_dataone_orgservicetypesv2_0_SystemMetadata_seriesId', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 107, 8), )

    
    seriesId = property(__seriesId.value, __seriesId.set, None, u'The :term:`seriesId` is a unique Unicode string\n\t\t\t\t          that can be used to identify an object revision chain in DataONE.\n\t\t\t\t          When included, the seriesId can be used to reference the latest version of\n\t\t\t\t          and object in the revision chain. API methods that rely on byte fixity\n\t\t\t\t          (e.g. for content replication) will not accept seriesId in place of discrete identifiers.\n\t\t\t\t          The values used for seriesId must be unique within DataONE and cannot be the same as the\n\t\t\t\t          primary identifier of an object. The same encoding rules used for identifier values apply\n\t\t\t\t          to seriesId values.')

    _ElementMap.update({
        __seriesId.name() : __seriesId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SystemMetadata', SystemMetadata)


# Complex type {http://ns.dataone.org/service/types/v2.0}NodeList with content type ELEMENT_ONLY
class NodeList (pyxb.binding.basis.complexTypeDefinition):
    """ A list of :class:`Types.Node` entries returned by
	    :func:`CNCore.listNodes()`.NodeList is described in
	     :mod:`NodeList`."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NodeList')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 125, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element node uses Python identifier node
    __node = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'node'), 'node', '__httpns_dataone_orgservicetypesv2_0_NodeList_node', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 133, 5), )

    
    node = property(__node.value, __node.set, None, None)

    _ElementMap.update({
        __node.name() : __node
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'NodeList', NodeList)


# Complex type {http://ns.dataone.org/service/types/v2.0}Node with content type ELEMENT_ONLY
class Node (_ImportedBinding_dataoneTypes.Node):
    """A set of values that describe a member or coordinating
	      node, its Internet location, and the services it supports. Several nodes
	      may exist on a single physical device or hostname. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Node')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 139, 1)
    _ElementMap = _ImportedBinding_dataoneTypes.Node._ElementMap.copy()
    _AttributeMap = _ImportedBinding_dataoneTypes.Node._AttributeMap.copy()
    # Base type is _ImportedBinding_dataoneTypes.Node
    
    # Element identifier (identifier) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element name (name) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element description (description) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element baseURL (baseURL) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element services (services) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element synchronization (synchronization) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element nodeReplicationPolicy (nodeReplicationPolicy) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element ping (ping) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element subject (subject) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element contactSubject (contactSubject) inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Element serviceExtensions uses Python identifier serviceExtensions
    __serviceExtensions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'serviceExtensions'), 'serviceExtensions', '__httpns_dataone_orgservicetypesv2_0_Node_serviceExtensions', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 148, 5), )

    
    serviceExtensions = property(__serviceExtensions.value, __serviceExtensions.set, None, u'TODO: define the content of this?')

    
    # Element property uses Python identifier property_
    __property = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'property'), 'property_', '__httpns_dataone_orgservicetypesv2_0_Node_property', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 153, 5), )

    
    property_ = property(__property.value, __property.set, None, u'Allows additional attributes be added to the Node document as needed')

    
    # Attribute replicate inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Attribute synchronize inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Attribute type inherited from {http://ns.dataone.org/service/types/v1}Node
    
    # Attribute state inherited from {http://ns.dataone.org/service/types/v1}Node
    _ElementMap.update({
        __serviceExtensions.name() : __serviceExtensions,
        __property.name() : __property
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'Node', Node)


# Complex type {http://ns.dataone.org/service/types/v2.0}ServiceExtension with content type ELEMENT_ONLY
class ServiceExtension (pyxb.binding.basis.complexTypeDefinition):
    """
			The goal of Member Node Service Registration (MNSR) is to assist clients in discovery
			of services exposed by Member Nodes that may be applicable to a particular type of object
			"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ServiceExtension')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 164, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpns_dataone_orgservicetypesv2_0_ServiceExtension_name', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 172, 3), )

    
    name = property(__name.value, __name.set, None, u'Descriptive human-readable name of the service.\n\t\t\t\t\t')

    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'type'), 'type', '__httpns_dataone_orgservicetypesv2_0_ServiceExtension_type', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 178, 3), )

    
    type = property(__type.value, __type.set, None, u'Unique Service Type identifier.\n\t\t\t\t\t')

    
    # Element description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'description'), 'description', '__httpns_dataone_orgservicetypesv2_0_ServiceExtension_description', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 184, 3), )

    
    description = property(__description.value, __description.set, None, u'Brief human readable description of service to be\n                        presented in user interfaces.\n\t\t\t\t\t')

    
    # Element connection uses Python identifier connection
    __connection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'connection'), 'connection', '__httpns_dataone_orgservicetypesv2_0_ServiceExtension_connection', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 191, 3), )

    
    connection = property(__connection.value, __connection.set, None, u'Endpoint where the service is available\n\t\t\t\t\t')

    
    # Element formats uses Python identifier formats
    __formats = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'formats'), 'formats', '__httpns_dataone_orgservicetypesv2_0_ServiceExtension_formats', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 198, 3), )

    
    formats = property(__formats.value, __formats.set, None, u'A list of formats supported by the service.\n\t\t\t\t\t')

    _ElementMap.update({
        __name.name() : __name,
        __type.name() : __type,
        __description.name() : __description,
        __connection.name() : __connection,
        __formats.name() : __formats
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ServiceExtension', ServiceExtension)


# Complex type {http://ns.dataone.org/service/types/v2.0}FormatList with content type ELEMENT_ONLY
class FormatList (pyxb.binding.basis.complexTypeDefinition):
    """A list of ObjectFormatId elements
			"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FormatList')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 208, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element formatType uses Python identifier formatType
    __formatType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'formatType'), 'formatType', '__httpns_dataone_orgservicetypesv2_0_FormatList_formatType', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 214, 3), )

    
    formatType = property(__formatType.value, __formatType.set, None, None)

    _ElementMap.update({
        __formatType.name() : __formatType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'FormatList', FormatList)


# Complex type {http://ns.dataone.org/service/types/v2.0}Property with content type SIMPLE
class Property (pyxb.binding.basis.complexTypeDefinition):
    """Additional Property elements can be included to describe the Node in more detail.
	      Some properties will come from controlled vocabularies, indicated by the type attribute, while
	      others will be free-form key value pairs."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Property')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 220, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute key uses Python identifier key
    __key = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'key'), 'key', '__httpns_dataone_orgservicetypesv2_0_Property_key', pyxb.binding.datatypes.string, required=True)
    __key._DeclarationLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 228, 7)
    __key._UseLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 228, 7)
    
    key = property(__key.value, __key.set, None, u'The property key for this entry. Should be unique within the Node element')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'type'), 'type', '__httpns_dataone_orgservicetypesv2_0_Property_type', pyxb.binding.datatypes.string)
    __type._DeclarationLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 233, 7)
    __type._UseLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 233, 7)
    
    type = property(__type.value, __type.set, None, u'The optional type for the property. Can be used to indicate if a controlled vocabulary is used for the\n\t\t\t        \tproperty key to better facilitate machine interpretation.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __key.name() : __key,
        __type.name() : __type
    })
Namespace.addCategoryObject('typeBinding', u'Property', Property)


# Complex type {http://ns.dataone.org/service/types/v2.0}ObjectFormat with content type ELEMENT_ONLY
class ObjectFormat (_ImportedBinding_dataoneTypes.ObjectFormat):
    """One value from the DataONE Object Format Vocabulary
			which is returned by :func:`CNCore.getFormat()`.An *ObjectFormat* is the structure returned from the
			:func:`CNCore.getFormat()` method of the CN REST interface. It provides
			the unique identifier and the name associated with the object format.
			Future versions may contain additional structured content from external
			common typing systems. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObjectFormat')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 244, 1)
    _ElementMap = _ImportedBinding_dataoneTypes.ObjectFormat._ElementMap.copy()
    _AttributeMap = _ImportedBinding_dataoneTypes.ObjectFormat._AttributeMap.copy()
    # Base type is _ImportedBinding_dataoneTypes.ObjectFormat
    
    # Element formatId (formatId) inherited from {http://ns.dataone.org/service/types/v1}ObjectFormat
    
    # Element formatName (formatName) inherited from {http://ns.dataone.org/service/types/v1}ObjectFormat
    
    # Element formatType (formatType) inherited from {http://ns.dataone.org/service/types/v1}ObjectFormat
    
    # Element mimeType uses Python identifier mimeType
    __mimeType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'mimeType'), 'mimeType', '__httpns_dataone_orgservicetypesv2_0_ObjectFormat_mimeType', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 257, 8), )

    
    mimeType = property(__mimeType.value, __mimeType.set, None, u'The MIME type for this object format.')

    
    # Element extension uses Python identifier extension
    __extension = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'extension'), 'extension', '__httpns_dataone_orgservicetypesv2_0_ObjectFormat_extension', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 262, 5), )

    
    extension = property(__extension.value, __extension.set, None, u'The extension to be used when serializing the object to a file.')

    _ElementMap.update({
        __mimeType.name() : __mimeType,
        __extension.name() : __extension
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObjectFormat', ObjectFormat)


# Complex type {http://ns.dataone.org/service/types/v2.0}ObjectFormatList with content type ELEMENT_ONLY
class ObjectFormatList (_ImportedBinding_dataoneTypes.Slice):
    """An ObjectFormatList is the structure returned from the
		  :func:`CNCore.listFormats()` method of the CN REST interface. It
		  provides a list of named object formats defined in the DataONE system.
		  Each :class:`Types.ObjectFormat` returned in the list describes the
		  object format via its name, and future versions may contain additional
		  structured content from common external typing systems.
		  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObjectFormatList')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 273, 1)
    _ElementMap = _ImportedBinding_dataoneTypes.Slice._ElementMap.copy()
    _AttributeMap = _ImportedBinding_dataoneTypes.Slice._AttributeMap.copy()
    # Base type is _ImportedBinding_dataoneTypes.Slice
    
    # Element objectFormat uses Python identifier objectFormat
    __objectFormat = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'objectFormat'), 'objectFormat', '__httpns_dataone_orgservicetypesv2_0_ObjectFormatList_objectFormat', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 286, 8), )

    
    objectFormat = property(__objectFormat.value, __objectFormat.set, None, None)

    
    # Attribute count inherited from {http://ns.dataone.org/service/types/v1}Slice
    
    # Attribute start inherited from {http://ns.dataone.org/service/types/v1}Slice
    
    # Attribute total inherited from {http://ns.dataone.org/service/types/v1}Slice
    _ElementMap.update({
        __objectFormat.name() : __objectFormat
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObjectFormatList', ObjectFormatList)


# Complex type {http://ns.dataone.org/service/types/v2.0}Log with content type ELEMENT_ONLY
class Log (_ImportedBinding_dataoneTypes.Slice):
    """Represents a collection of :class:`Types.LogEntry`
	    elements, used to transfer log information between DataONE
	    components."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Log')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 294, 1)
    _ElementMap = _ImportedBinding_dataoneTypes.Slice._ElementMap.copy()
    _AttributeMap = _ImportedBinding_dataoneTypes.Slice._AttributeMap.copy()
    # Base type is _ImportedBinding_dataoneTypes.Slice
    
    # Element logEntry uses Python identifier logEntry
    __logEntry = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'logEntry'), 'logEntry', '__httpns_dataone_orgservicetypesv2_0_Log_logEntry', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 303, 9), )

    
    logEntry = property(__logEntry.value, __logEntry.set, None, None)

    
    # Attribute count inherited from {http://ns.dataone.org/service/types/v1}Slice
    
    # Attribute start inherited from {http://ns.dataone.org/service/types/v1}Slice
    
    # Attribute total inherited from {http://ns.dataone.org/service/types/v1}Slice
    _ElementMap.update({
        __logEntry.name() : __logEntry
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'Log', Log)


# Complex type {http://ns.dataone.org/service/types/v2.0}LogEntry with content type ELEMENT_ONLY
class LogEntry (pyxb.binding.basis.complexTypeDefinition):
    """A single log entry as reported by a Member Node or
	    Coordinating Node through the :func:`MNCore.getLogRecords` or
	    :func:`CNCore.getLogRecords` methods."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LogEntry')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 311, 1)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element entryId uses Python identifier entryId
    __entryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'entryId'), 'entryId', '__httpns_dataone_orgservicetypesv2_0_LogEntry_entryId', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 318, 5), )

    
    entryId = property(__entryId.value, __entryId.set, None, u'A unique identifier for this log entry. The\n\t        identifier should be unique for a particular node; This is not drawn\n\t        from the same value space as other identifiers in DataONE, and so is\n\t        not subjec to the same restrictions.')

    
    # Element identifier uses Python identifier identifier
    __identifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'identifier'), 'identifier', '__httpns_dataone_orgservicetypesv2_0_LogEntry_identifier', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 327, 5), )

    
    identifier = property(__identifier.value, __identifier.set, None, u'The :term:`identifier` of the object that was the\n\t        target of the operation which generated this log entry.')

    
    # Element ipAddress uses Python identifier ipAddress
    __ipAddress = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'ipAddress'), 'ipAddress', '__httpns_dataone_orgservicetypesv2_0_LogEntry_ipAddress', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 334, 5), )

    
    ipAddress = property(__ipAddress.value, __ipAddress.set, None, u'The IP address, as reported by the service receiving\n\t        the request, of the request origin.')

    
    # Element userAgent uses Python identifier userAgent
    __userAgent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'userAgent'), 'userAgent', '__httpns_dataone_orgservicetypesv2_0_LogEntry_userAgent', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 341, 5), )

    
    userAgent = property(__userAgent.value, __userAgent.set, None, u'The user agent of the client making the request, as\n\t        reported in the User-Agent HTTP header.')

    
    # Element subject uses Python identifier subject
    __subject = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'subject'), 'subject', '__httpns_dataone_orgservicetypesv2_0_LogEntry_subject', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 348, 5), )

    
    subject = property(__subject.value, __subject.set, None, u'The :term:`Subject` used for making the request.\n\t        This may be the DataONE :term:`public` user if the request is not\n\t        authenticated, otherwise it will be the *Subject* of the certificate\n\t        used for authenticating the request.')

    
    # Element event uses Python identifier event
    __event = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'event'), 'event', '__httpns_dataone_orgservicetypesv2_0_LogEntry_event', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 357, 5), )

    
    event = property(__event.value, __event.set, None, u'A non-empty string that indicates the type of even logged.\n\t        A value from the :class:`Types.Event` enumeration is recommended but no longer required.')

    
    # Element dateLogged uses Python identifier dateLogged
    __dateLogged = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'dateLogged'), 'dateLogged', '__httpns_dataone_orgservicetypesv2_0_LogEntry_dateLogged', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 364, 5), )

    
    dateLogged = property(__dateLogged.value, __dateLogged.set, None, u'A :class:`Types.DateTime` time stamp indicating when\n\t        the event triggering the log message ocurred. Note that all time\n\t        stamps in DataONE are in UTC.')

    
    # Element nodeIdentifier uses Python identifier nodeIdentifier
    __nodeIdentifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'nodeIdentifier'), 'nodeIdentifier', '__httpns_dataone_orgservicetypesv2_0_LogEntry_nodeIdentifier', False, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 372, 5), )

    
    nodeIdentifier = property(__nodeIdentifier.value, __nodeIdentifier.set, None, u'The unique identifier for the node where the log\n\t        message was generated.')

    _ElementMap.update({
        __entryId.name() : __entryId,
        __identifier.name() : __identifier,
        __ipAddress.name() : __ipAddress,
        __userAgent.name() : __userAgent,
        __subject.name() : __subject,
        __event.name() : __event,
        __dateLogged.name() : __dateLogged,
        __nodeIdentifier.name() : __nodeIdentifier
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LogEntry', LogEntry)


# Complex type {http://ns.dataone.org/service/types/v2.0}OptionList with content type ELEMENT_ONLY
class OptionList (pyxb.binding.basis.complexTypeDefinition):
    """A list of options that indicate the possible values for
        a DataONE service.  Each option that can be validly sent to a service is listed, providing the specific key that should be used when interacting with the service, as well as a description of that key that allows API users to understand the usage of the key.  For example, an OptionList might contain a list of themes that can be used with the MNView.view service, or for other services that have a configurable but controlled set of parameters."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OptionList')
    _XSDLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 384, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, u'option'), 'option', '__httpns_dataone_orgservicetypesv2_0_OptionList_option', True, pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 390, 6), )

    
    option = property(__option.value, __option.set, None, u"The key to be used within an API call to a DataONE\n          service, including a description of the key and its impact on the\n          service. For example, a key 'default' can be provided as the theme for\n          the MNView.view service.  Keys must not contain characters that will\n          need to be URL escaped.")

    
    # Attribute key uses Python identifier key
    __key = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'key'), 'key', '__httpns_dataone_orgservicetypesv2_0_OptionList_key', pyxb.binding.datatypes.string, required=True)
    __key._DeclarationLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 401, 4)
    __key._UseLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 401, 4)
    
    key = property(__key.value, __key.set, None, u'A value that can be used with a DataONE\n        service. Key values must not contain any characters that need to be\n        URL escaped, and should be short and informative.\n        ')

    
    # Attribute description uses Python identifier description
    __description = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'description'), 'description', '__httpns_dataone_orgservicetypesv2_0_OptionList_description', pyxb.binding.datatypes.string, required=True)
    __description._DeclarationLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 409, 4)
    __description._UseLocation = pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 409, 4)
    
    description = property(__description.value, __description.set, None, u'The description of an option, indicating its\n        intended use and impact on a DataONE service invocation.')

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        __key.name() : __key,
        __description.name() : __description
    })
Namespace.addCategoryObject('typeBinding', u'OptionList', OptionList)


optionList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'optionList'), OptionList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 430, 2))
Namespace.addCategoryObject('elementBinding', optionList.name().localName(), optionList)

systemMetadata = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'systemMetadata'), SystemMetadata, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 431, 2))
Namespace.addCategoryObject('elementBinding', systemMetadata.name().localName(), systemMetadata)

node = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'node'), Node, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 432, 2))
Namespace.addCategoryObject('elementBinding', node.name().localName(), node)

nodeList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'nodeList'), NodeList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 433, 2))
Namespace.addCategoryObject('elementBinding', nodeList.name().localName(), nodeList)

objectFormat = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'objectFormat'), ObjectFormat, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 434, 2))
Namespace.addCategoryObject('elementBinding', objectFormat.name().localName(), objectFormat)

objectFormatList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'objectFormatList'), ObjectFormatList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 435, 2))
Namespace.addCategoryObject('elementBinding', objectFormatList.name().localName(), objectFormatList)

log = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'log'), Log, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 436, 2))
Namespace.addCategoryObject('elementBinding', log.name().localName(), log)

logEntry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'logEntry'), LogEntry, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 437, 2))
Namespace.addCategoryObject('elementBinding', logEntry.name().localName(), logEntry)



SystemMetadata._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'seriesId'), _ImportedBinding_dataoneTypes.Identifier, scope=SystemMetadata, documentation=u'The :term:`seriesId` is a unique Unicode string\n\t\t\t\t          that can be used to identify an object revision chain in DataONE.\n\t\t\t\t          When included, the seriesId can be used to reference the latest version of\n\t\t\t\t          and object in the revision chain. API methods that rely on byte fixity\n\t\t\t\t          (e.g. for content replication) will not accept seriesId in place of discrete identifiers.\n\t\t\t\t          The values used for seriesId must be unique within DataONE and cannot be the same as the\n\t\t\t\t          primary identifier of an object. The same encoding rules used for identifier values apply\n\t\t\t\t          to seriesId values.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 107, 8)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1354, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1422, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1451, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1466, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1478, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1488, 6))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1499, 6))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1510, 6))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1522, 6))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1533, 6))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1541, 6))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1554, 6))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 107, 8))
    counters.add(cc_12)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'serialVersion')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1354, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'identifier')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1366, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'formatId')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1392, 6))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'size')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1407, 6))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'checksum')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1413, 6))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'submitter')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1422, 6))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'rightsHolder')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1435, 6))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'accessPolicy')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1451, 6))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'replicationPolicy')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1466, 6))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'obsoletes')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1478, 6))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'obsoletedBy')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1488, 6))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'archived')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1499, 6))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'dateUploaded')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1510, 6))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'dateSysMetadataModified')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1522, 6))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'originMemberNode')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1533, 6))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'authoritativeMemberNode')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1541, 6))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'replica')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 1554, 6))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(SystemMetadata._UseForTag(pyxb.namespace.ExpandedName(None, u'seriesId')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 107, 8))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, True) ]))
    st_17._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SystemMetadata._Automaton = _BuildAutomaton()




NodeList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'node'), Node, scope=NodeList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 133, 5)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NodeList._UseForTag(pyxb.namespace.ExpandedName(None, u'node')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 133, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NodeList._Automaton = _BuildAutomaton_()




Node._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'serviceExtensions'), ServiceExtension, scope=Node, documentation=u'TODO: define the content of this?', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 148, 5)))

Node._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'property'), Property, scope=Node, documentation=u'Allows additional attributes be added to the Node document as needed', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 153, 5)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 551, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 558, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 568, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 579, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 585, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 148, 5))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 153, 5))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'identifier')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 516, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'name')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 526, 6))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'description')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 533, 6))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'baseURL')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 542, 6))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'services')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 551, 6))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'synchronization')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 558, 6))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'nodeReplicationPolicy')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 568, 6))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'ping')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 579, 6))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'subject')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 585, 6))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'contactSubject')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 599, 6))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'serviceExtensions')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 148, 5))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Node._UseForTag(pyxb.namespace.ExpandedName(None, u'property')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 153, 5))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Node._Automaton = _BuildAutomaton_2()




ServiceExtension._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'name'), pyxb.binding.datatypes.string, scope=ServiceExtension, documentation=u'Descriptive human-readable name of the service.\n\t\t\t\t\t', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 172, 3)))

ServiceExtension._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'type'), pyxb.binding.datatypes.string, scope=ServiceExtension, documentation=u'Unique Service Type identifier.\n\t\t\t\t\t', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 178, 3)))

ServiceExtension._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'description'), pyxb.binding.datatypes.string, scope=ServiceExtension, documentation=u'Brief human readable description of service to be\n                        presented in user interfaces.\n\t\t\t\t\t', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 184, 3)))

ServiceExtension._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'connection'), pyxb.binding.datatypes.anyURI, scope=ServiceExtension, documentation=u'Endpoint where the service is available\n\t\t\t\t\t', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 191, 3)))

ServiceExtension._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'formats'), FormatList, scope=ServiceExtension, documentation=u'A list of formats supported by the service.\n\t\t\t\t\t', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 198, 3)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 178, 3))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 184, 3))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 191, 3))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 198, 3))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ServiceExtension._UseForTag(pyxb.namespace.ExpandedName(None, u'name')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 172, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ServiceExtension._UseForTag(pyxb.namespace.ExpandedName(None, u'type')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 178, 3))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ServiceExtension._UseForTag(pyxb.namespace.ExpandedName(None, u'description')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 184, 3))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ServiceExtension._UseForTag(pyxb.namespace.ExpandedName(None, u'connection')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 191, 3))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ServiceExtension._UseForTag(pyxb.namespace.ExpandedName(None, u'formats')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 198, 3))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ServiceExtension._Automaton = _BuildAutomaton_3()




FormatList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'formatType'), _ImportedBinding_dataoneTypes.ObjectFormatIdentifier, scope=FormatList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 214, 3)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FormatList._UseForTag(pyxb.namespace.ExpandedName(None, u'formatType')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 214, 3))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FormatList._Automaton = _BuildAutomaton_4()




ObjectFormat._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'mimeType'), pyxb.binding.datatypes.string, scope=ObjectFormat, documentation=u'The MIME type for this object format.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 257, 8)))

ObjectFormat._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'extension'), pyxb.binding.datatypes.string, scope=ObjectFormat, documentation=u'The extension to be used when serializing the object to a file.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 262, 5)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 257, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 262, 5))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ObjectFormat._UseForTag(pyxb.namespace.ExpandedName(None, u'formatId')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 730, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ObjectFormat._UseForTag(pyxb.namespace.ExpandedName(None, u'formatName')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 739, 6))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ObjectFormat._UseForTag(pyxb.namespace.ExpandedName(None, u'formatType')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes.xsd', 748, 6))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ObjectFormat._UseForTag(pyxb.namespace.ExpandedName(None, u'mimeType')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 257, 8))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ObjectFormat._UseForTag(pyxb.namespace.ExpandedName(None, u'extension')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 262, 5))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ObjectFormat._Automaton = _BuildAutomaton_5()




ObjectFormatList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'objectFormat'), ObjectFormat, scope=ObjectFormatList, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 286, 8)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ObjectFormatList._UseForTag(pyxb.namespace.ExpandedName(None, u'objectFormat')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 286, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ObjectFormatList._Automaton = _BuildAutomaton_6()




Log._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'logEntry'), LogEntry, scope=Log, location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 303, 9)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 303, 9))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Log._UseForTag(pyxb.namespace.ExpandedName(None, u'logEntry')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 303, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Log._Automaton = _BuildAutomaton_7()




LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'entryId'), _ImportedBinding_dataoneTypes.NonEmptyString, scope=LogEntry, documentation=u'A unique identifier for this log entry. The\n\t        identifier should be unique for a particular node; This is not drawn\n\t        from the same value space as other identifiers in DataONE, and so is\n\t        not subjec to the same restrictions.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 318, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'identifier'), _ImportedBinding_dataoneTypes.Identifier, scope=LogEntry, documentation=u'The :term:`identifier` of the object that was the\n\t        target of the operation which generated this log entry.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 327, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'ipAddress'), pyxb.binding.datatypes.string, scope=LogEntry, documentation=u'The IP address, as reported by the service receiving\n\t        the request, of the request origin.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 334, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'userAgent'), pyxb.binding.datatypes.string, scope=LogEntry, documentation=u'The user agent of the client making the request, as\n\t        reported in the User-Agent HTTP header.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 341, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'subject'), _ImportedBinding_dataoneTypes.Subject, scope=LogEntry, documentation=u'The :term:`Subject` used for making the request.\n\t        This may be the DataONE :term:`public` user if the request is not\n\t        authenticated, otherwise it will be the *Subject* of the certificate\n\t        used for authenticating the request.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 348, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'event'), _ImportedBinding_dataoneTypes.NonEmptyString, scope=LogEntry, documentation=u'A non-empty string that indicates the type of even logged.\n\t        A value from the :class:`Types.Event` enumeration is recommended but no longer required.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 357, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'dateLogged'), pyxb.binding.datatypes.dateTime, scope=LogEntry, documentation=u'A :class:`Types.DateTime` time stamp indicating when\n\t        the event triggering the log message ocurred. Note that all time\n\t        stamps in DataONE are in UTC.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 364, 5)))

LogEntry._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'nodeIdentifier'), _ImportedBinding_dataoneTypes.NodeReference, scope=LogEntry, documentation=u'The unique identifier for the node where the log\n\t        message was generated.', location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 372, 5)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'entryId')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 318, 5))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'identifier')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 327, 5))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'ipAddress')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 334, 5))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'userAgent')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 341, 5))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'subject')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 348, 5))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'event')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 357, 5))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'dateLogged')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 364, 5))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(LogEntry._UseForTag(pyxb.namespace.ExpandedName(None, u'nodeIdentifier')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 372, 5))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
LogEntry._Automaton = _BuildAutomaton_8()




OptionList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, u'option'), _ImportedBinding_dataoneTypes.NonEmptyString, scope=OptionList, documentation=u"The key to be used within an API call to a DataONE\n          service, including a description of the key and its impact on the\n          service. For example, a key 'default' can be provided as the theme for\n          the MNView.view service.  Keys must not contain characters that will\n          need to be URL escaped.", location=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 390, 6)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 390, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(OptionList._UseForTag(pyxb.namespace.ExpandedName(None, u'option')), pyxb.utils.utility.Location('/home/dahl/d1/d1_python/d1_common_python/src/d1_schemas/dataoneTypes_v2.0.xsd', 390, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
OptionList._Automaton = _BuildAutomaton_9()

